/* eslint-disable */
/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import gql from 'graphql-tag';
import * as Urql from '@urql/vue';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any; }
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
   * 3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
   * that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
   * to unexpected results.
   */
  Datetime: { input: string; output: string; }
  /** Represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: any; output: any; }
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: { input: string; output: string; }
};

/** All input for the `acceptInvitationToOrganization` mutation. */
export type AcceptInvitationToOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  invitationId: Scalars['UUID']['input'];
};

/** The output of our `acceptInvitationToOrganization` mutation. */
export type AcceptInvitationToOrganizationPayload = {
  __typename?: 'AcceptInvitationToOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** All input for the `changePassword` mutation. */
export type ChangePasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  oldPassword: Scalars['String']['input'];
};

/** The output of our `changePassword` mutation. */
export type ChangePasswordPayload = {
  __typename?: 'ChangePasswordPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
};

/** The output of our `confirmAccountDeletion` mutation. */
export type ConfirmAccountDeletionPayload = {
  __typename?: 'ConfirmAccountDeletionPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type Consultation = Node & {
  __typename?: 'Consultation';
  /** Reads and enables pagination through a set of `ConsultationParticipant`. */
  consultationParticipants: ConsultationParticipantsConnection;
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `Message`. */
  messages: MessagesConnection;
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `Consultation`. */
  organization: Maybe<Organization>;
  organizationId: Scalars['UUID']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type ConsultationConsultationParticipantsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ConsultationParticipantCondition>;
  filter?: InputMaybe<ConsultationParticipantFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultationParticipantsOrderBy>>;
};


export type ConsultationMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageCondition>;
  filter?: InputMaybe<MessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/**
 * A condition to be used against `Consultation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConsultationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Consultation` object types. All fields are combined with a logical ‘and.’ */
export type ConsultationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ConsultationFilter>>;
  /** Filter by the object’s `consultationParticipants` relation. */
  consultationParticipants?: InputMaybe<ConsultationToManyConsultationParticipantFilter>;
  /** Some related `consultationParticipants` exist. */
  consultationParticipantsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `messages` relation. */
  messages?: InputMaybe<ConsultationToManyMessageFilter>;
  /** Some related `messages` exist. */
  messagesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ConsultationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ConsultationFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Consultation` */
export type ConsultationInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  name: Scalars['String']['input'];
  organizationId: Scalars['UUID']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type ConsultationParticipant = Node & {
  __typename?: 'ConsultationParticipant';
  /** Reads a single `Consultation` that is related to this `ConsultationParticipant`. */
  consultation: Maybe<Consultation>;
  consultationId: Scalars['UUID']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isClient: Scalars['Boolean']['output'];
  isCounselor: Scalars['Boolean']['output'];
  isSupervisor: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sysPeriod: DatetimeRange;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `ConsultationParticipant`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `ConsultationParticipant` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ConsultationParticipantCondition = {
  /** Checks for equality with the object’s `consultationId` field. */
  consultationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isClient` field. */
  isClient?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isCounselor` field. */
  isCounselor?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSupervisor` field. */
  isSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `sysPeriod` field. */
  sysPeriod?: InputMaybe<DatetimeRangeInput>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `ConsultationParticipant` object types. All fields are combined with a logical ‘and.’ */
export type ConsultationParticipantFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ConsultationParticipantFilter>>;
  /** Filter by the object’s `consultation` relation. */
  consultation?: InputMaybe<ConsultationFilter>;
  /** Filter by the object’s `consultationId` field. */
  consultationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isClient` field. */
  isClient?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isCounselor` field. */
  isCounselor?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSupervisor` field. */
  isSupervisor?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ConsultationParticipantFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ConsultationParticipantFilter>>;
  /** Filter by the object’s `sysPeriod` field. */
  sysPeriod?: InputMaybe<DatetimeRangeFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `ConsultationParticipant` */
export type ConsultationParticipantInput = {
  consultationId: Scalars['UUID']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isClient?: InputMaybe<Scalars['Boolean']['input']>;
  isCounselor?: InputMaybe<Scalars['Boolean']['input']>;
  isSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  sysPeriod?: InputMaybe<DatetimeRangeInput>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `ConsultationParticipant`. Fields that are set will be updated. */
export type ConsultationParticipantPatch = {
  consultationId?: InputMaybe<Scalars['UUID']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isClient?: InputMaybe<Scalars['Boolean']['input']>;
  isCounselor?: InputMaybe<Scalars['Boolean']['input']>;
  isSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  sysPeriod?: InputMaybe<DatetimeRangeInput>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `ConsultationParticipant` values. */
export type ConsultationParticipantsConnection = {
  __typename?: 'ConsultationParticipantsConnection';
  /** A list of edges which contains the `ConsultationParticipant` and cursor to aid in pagination. */
  edges: Array<Maybe<ConsultationParticipantsEdge>>;
  /** A list of `ConsultationParticipant` objects. */
  nodes: Array<Maybe<ConsultationParticipant>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ConsultationParticipant` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ConsultationParticipant` edge in the connection. */
export type ConsultationParticipantsEdge = {
  __typename?: 'ConsultationParticipantsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `ConsultationParticipant` at the end of the edge. */
  node: Maybe<ConsultationParticipant>;
};

/** Methods to use when ordering `ConsultationParticipant`. */
export type ConsultationParticipantsOrderBy =
  | 'CONSULTATION_ID_ASC'
  | 'CONSULTATION_ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_CLIENT_ASC'
  | 'IS_CLIENT_DESC'
  | 'IS_COUNSELOR_ASC'
  | 'IS_COUNSELOR_DESC'
  | 'IS_SUPERVISOR_ASC'
  | 'IS_SUPERVISOR_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** Represents an update to a `Consultation`. Fields that are set will be updated. */
export type ConsultationPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `ConsultationParticipant` object types. All fields are combined with a logical ‘and.’ */
export type ConsultationToManyConsultationParticipantFilter = {
  /** Every related `ConsultationParticipant` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ConsultationParticipantFilter>;
  /** No related `ConsultationParticipant` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ConsultationParticipantFilter>;
  /** Some related `ConsultationParticipant` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ConsultationParticipantFilter>;
};

/** A filter to be used against many `Message` object types. All fields are combined with a logical ‘and.’ */
export type ConsultationToManyMessageFilter = {
  /** Every related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageFilter>;
  /** No related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageFilter>;
  /** Some related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageFilter>;
};

/** A connection to a list of `Consultation` values. */
export type ConsultationsConnection = {
  __typename?: 'ConsultationsConnection';
  /** A list of edges which contains the `Consultation` and cursor to aid in pagination. */
  edges: Array<Maybe<ConsultationsEdge>>;
  /** A list of `Consultation` objects. */
  nodes: Array<Maybe<Consultation>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Consultation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Consultation` edge in the connection. */
export type ConsultationsEdge = {
  __typename?: 'ConsultationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Consultation` at the end of the edge. */
  node: Maybe<Consultation>;
};

/** Methods to use when ordering `Consultation`. */
export type ConsultationsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** All input for the create `Consultation` mutation. */
export type CreateConsultationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Consultation` to be created by this mutation. */
  consultation: ConsultationInput;
};

/** All input for the create `ConsultationParticipant` mutation. */
export type CreateConsultationParticipantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ConsultationParticipant` to be created by this mutation. */
  consultationParticipant: ConsultationParticipantInput;
};

/** The output of our create `ConsultationParticipant` mutation. */
export type CreateConsultationParticipantPayload = {
  __typename?: 'CreateConsultationParticipantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Consultation` that is related to this `ConsultationParticipant`. */
  consultation: Maybe<Consultation>;
  /** The `ConsultationParticipant` that was created by this mutation. */
  consultationParticipant: Maybe<ConsultationParticipant>;
  /** An edge for our `ConsultationParticipant`. May be used by Relay 1. */
  consultationParticipantEdge: Maybe<ConsultationParticipantsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ConsultationParticipant`. */
  user: Maybe<User>;
};


/** The output of our create `ConsultationParticipant` mutation. */
export type CreateConsultationParticipantPayloadConsultationParticipantEdgeArgs = {
  orderBy?: Array<ConsultationParticipantsOrderBy>;
};

/** The output of our create `Consultation` mutation. */
export type CreateConsultationPayload = {
  __typename?: 'CreateConsultationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Consultation` that was created by this mutation. */
  consultation: Maybe<Consultation>;
  /** An edge for our `Consultation`. May be used by Relay 1. */
  consultationEdge: Maybe<ConsultationsEdge>;
  /** Reads a single `Organization` that is related to this `Consultation`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Consultation` mutation. */
export type CreateConsultationPayloadConsultationEdgeArgs = {
  orderBy?: Array<ConsultationsOrderBy>;
};

/** All input for the create `MessageBodyRevisionApproval` mutation. */
export type CreateMessageBodyRevisionApprovalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MessageBodyRevisionApproval` to be created by this mutation. */
  messageBodyRevisionApproval: MessageBodyRevisionApprovalInput;
};

/** The output of our create `MessageBodyRevisionApproval` mutation. */
export type CreateMessageBodyRevisionApprovalPayload = {
  __typename?: 'CreateMessageBodyRevisionApprovalPayload';
  /** Reads a single `User` that is related to this `MessageBodyRevisionApproval`. */
  approver: Maybe<User>;
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionApproval`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `MessageBodyRevisionApproval` that was created by this mutation. */
  messageBodyRevisionApproval: Maybe<MessageBodyRevisionApproval>;
  /** An edge for our `MessageBodyRevisionApproval`. May be used by Relay 1. */
  messageBodyRevisionApprovalEdge: Maybe<MessageBodyRevisionApprovalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `MessageBodyRevisionApproval` mutation. */
export type CreateMessageBodyRevisionApprovalPayloadMessageBodyRevisionApprovalEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionApprovalsOrderBy>;
};

/** All input for the create `MessageBodyRevisionComment` mutation. */
export type CreateMessageBodyRevisionCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MessageBodyRevisionComment` to be created by this mutation. */
  messageBodyRevisionComment: MessageBodyRevisionCommentInput;
};

/** The output of our create `MessageBodyRevisionComment` mutation. */
export type CreateMessageBodyRevisionCommentPayload = {
  __typename?: 'CreateMessageBodyRevisionCommentPayload';
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionComment`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `MessageBodyRevisionComment`. */
  commenter: Maybe<User>;
  /** The `MessageBodyRevisionComment` that was created by this mutation. */
  messageBodyRevisionComment: Maybe<MessageBodyRevisionComment>;
  /** An edge for our `MessageBodyRevisionComment`. May be used by Relay 1. */
  messageBodyRevisionCommentEdge: Maybe<MessageBodyRevisionCommentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `MessageBodyRevisionComment` mutation. */
export type CreateMessageBodyRevisionCommentPayloadMessageBodyRevisionCommentEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionCommentsOrderBy>;
};

/** All input for the create `MessageBodyRevision` mutation. */
export type CreateMessageBodyRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MessageBodyRevision` to be created by this mutation. */
  messageBodyRevision: MessageBodyRevisionInput;
};

/** The output of our create `MessageBodyRevision` mutation. */
export type CreateMessageBodyRevisionPayload = {
  __typename?: 'CreateMessageBodyRevisionPayload';
  /** Reads a single `User` that is related to this `MessageBodyRevision`. */
  author: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Message` that is related to this `MessageBodyRevision`. */
  message: Maybe<Message>;
  /** The `MessageBodyRevision` that was created by this mutation. */
  messageBodyRevision: Maybe<MessageBodyRevision>;
  /** An edge for our `MessageBodyRevision`. May be used by Relay 1. */
  messageBodyRevisionEdge: Maybe<MessageBodyRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `MessageBodyRevision` mutation. */
export type CreateMessageBodyRevisionPayloadMessageBodyRevisionEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionsOrderBy>;
};

/** All input for the create `Message` mutation. */
export type CreateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Message` to be created by this mutation. */
  message: MessageInput;
};

/** The output of our create `Message` mutation. */
export type CreateMessagePayload = {
  __typename?: 'CreateMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Consultation` that is related to this `Message`. */
  consultation: Maybe<Consultation>;
  /** The `Message` that was created by this mutation. */
  message: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Message`. */
  sender: Maybe<User>;
};


/** The output of our create `Message` mutation. */
export type CreateMessagePayloadMessageEdgeArgs = {
  orderBy?: Array<MessagesOrderBy>;
};

/** All input for the create `Organization` mutation. */
export type CreateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Organization` to be created by this mutation. */
  organization: OrganizationInput;
};

/** All input for the create `OrganizationInvitation` mutation. */
export type CreateOrganizationInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `OrganizationInvitation` to be created by this mutation. */
  organizationInvitation: OrganizationInvitationInput;
};

/** The output of our create `OrganizationInvitation` mutation. */
export type CreateOrganizationInvitationPayload = {
  __typename?: 'CreateOrganizationInvitationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationInvitation`. */
  organization: Maybe<Organization>;
  /** The `OrganizationInvitation` that was created by this mutation. */
  organizationInvitation: Maybe<OrganizationInvitation>;
  /** An edge for our `OrganizationInvitation`. May be used by Relay 1. */
  organizationInvitationEdge: Maybe<OrganizationInvitationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationInvitation`. */
  user: Maybe<User>;
};


/** The output of our create `OrganizationInvitation` mutation. */
export type CreateOrganizationInvitationPayloadOrganizationInvitationEdgeArgs = {
  orderBy?: Array<OrganizationInvitationsOrderBy>;
};

/** All input for the create `OrganizationMembership` mutation. */
export type CreateOrganizationMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `OrganizationMembership` to be created by this mutation. */
  organizationMembership: OrganizationMembershipInput;
};

/** The output of our create `OrganizationMembership` mutation. */
export type CreateOrganizationMembershipPayload = {
  __typename?: 'CreateOrganizationMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationMembership`. */
  organization: Maybe<Organization>;
  /** The `OrganizationMembership` that was created by this mutation. */
  organizationMembership: Maybe<OrganizationMembership>;
  /** An edge for our `OrganizationMembership`. May be used by Relay 1. */
  organizationMembershipEdge: Maybe<OrganizationMembershipsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationMembership`. */
  user: Maybe<User>;
};


/** The output of our create `OrganizationMembership` mutation. */
export type CreateOrganizationMembershipPayloadOrganizationMembershipEdgeArgs = {
  orderBy?: Array<OrganizationMembershipsOrderBy>;
};

/** The output of our create `Organization` mutation. */
export type CreateOrganizationPayload = {
  __typename?: 'CreateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Organization` that was created by this mutation. */
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our create `Organization` mutation. */
export type CreateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the create `UserAuthentication` mutation. */
export type CreateUserAuthenticationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserAuthentication` to be created by this mutation. */
  userAuthentication: UserAuthenticationInput;
};

/** The output of our create `UserAuthentication` mutation. */
export type CreateUserAuthenticationPayload = {
  __typename?: 'CreateUserAuthenticationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  /** The `UserAuthentication` that was created by this mutation. */
  userAuthentication: Maybe<UserAuthentication>;
  /** An edge for our `UserAuthentication`. May be used by Relay 1. */
  userAuthenticationEdge: Maybe<UserAuthenticationsEdge>;
};


/** The output of our create `UserAuthentication` mutation. */
export type CreateUserAuthenticationPayloadUserAuthenticationEdgeArgs = {
  orderBy?: Array<UserAuthenticationsOrderBy>;
};

/** All input for the create `UserEmail` mutation. */
export type CreateUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserEmail` to be created by this mutation. */
  userEmail: UserEmailInput;
};

/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayload = {
  __typename?: 'CreateUserEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  /** The `UserEmail` that was created by this mutation. */
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our create `UserEmail` mutation. */
export type CreateUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Array<UsersOrderBy>;
};

/** A connection to a list of `UUID` values. */
export type CurrentUserConsultationIdsConnection = {
  __typename?: 'CurrentUserConsultationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<CurrentUserConsultationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type CurrentUserConsultationIdsEdge = {
  __typename?: 'CurrentUserConsultationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type CurrentUserInvitedOrganizationIdsConnection = {
  __typename?: 'CurrentUserInvitedOrganizationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<CurrentUserInvitedOrganizationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type CurrentUserInvitedOrganizationIdsEdge = {
  __typename?: 'CurrentUserInvitedOrganizationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A connection to a list of `UUID` values. */
export type CurrentUserMemberOrganizationIdsConnection = {
  __typename?: 'CurrentUserMemberOrganizationIdsConnection';
  /** A list of edges which contains the `UUID` and cursor to aid in pagination. */
  edges: Array<Maybe<CurrentUserMemberOrganizationIdsEdge>>;
  /** A list of `UUID` objects. */
  nodes: Array<Maybe<Scalars['UUID']['output']>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UUID` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UUID` edge in the connection. */
export type CurrentUserMemberOrganizationIdsEdge = {
  __typename?: 'CurrentUserMemberOrganizationIdsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UUID` at the end of the edge. */
  node: Maybe<Scalars['UUID']['output']>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

/** A range of `Datetime`. */
export type DatetimeRange = {
  __typename?: 'DatetimeRange';
  /** The ending bound of our range. */
  end: Maybe<DatetimeRangeBound>;
  /** The starting bound of our range. */
  start: Maybe<DatetimeRangeBound>;
};

/** The value at one end of a range. A range can either include this value, or not. */
export type DatetimeRangeBound = {
  __typename?: 'DatetimeRangeBound';
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean']['output'];
  /** The value at one end of our range. */
  value: Scalars['Datetime']['output'];
};

/** The value at one end of a range. A range can either include this value, or not. */
export type DatetimeRangeBoundInput = {
  /** Whether or not the value of this bound is included in the range. */
  inclusive: Scalars['Boolean']['input'];
  /** The value at one end of our range. */
  value: Scalars['Datetime']['input'];
};

/** A filter to be used against DatetimeRange fields. All fields are combined with a logical ‘and.’ */
export type DatetimeRangeFilter = {
  /** Adjacent to the specified range. */
  adjacentTo?: InputMaybe<DatetimeRangeInput>;
  /** Contained by the specified range. */
  containedBy?: InputMaybe<DatetimeRangeInput>;
  /** Contains the specified range. */
  contains?: InputMaybe<DatetimeRangeInput>;
  /** Contains the specified value. */
  containsElement?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<DatetimeRangeInput>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<DatetimeRangeInput>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<DatetimeRangeInput>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<DatetimeRangeInput>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<DatetimeRangeInput>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<DatetimeRangeInput>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<DatetimeRangeInput>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<DatetimeRangeInput>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<DatetimeRangeInput>;
  /** Does not extend left of the specified range. */
  notExtendsLeftOf?: InputMaybe<DatetimeRangeInput>;
  /** Does not extend right of the specified range. */
  notExtendsRightOf?: InputMaybe<DatetimeRangeInput>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<DatetimeRangeInput>>;
  /** Overlaps the specified range. */
  overlaps?: InputMaybe<DatetimeRangeInput>;
  /** Strictly left of the specified range. */
  strictlyLeftOf?: InputMaybe<DatetimeRangeInput>;
  /** Strictly right of the specified range. */
  strictlyRightOf?: InputMaybe<DatetimeRangeInput>;
};

/** A range of `Datetime`. */
export type DatetimeRangeInput = {
  /** The ending bound of our range. */
  end?: InputMaybe<DatetimeRangeBoundInput>;
  /** The starting bound of our range. */
  start?: InputMaybe<DatetimeRangeBoundInput>;
};

/** All input for the `deleteConsultationByNodeId` mutation. */
export type DeleteConsultationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Consultation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteConsultation` mutation. */
export type DeleteConsultationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** All input for the `deleteConsultationParticipantByConsultationIdAndUserId` mutation. */
export type DeleteConsultationParticipantByConsultationIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  consultationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** All input for the `deleteConsultationParticipantByNodeId` mutation. */
export type DeleteConsultationParticipantByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ConsultationParticipant` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteConsultationParticipant` mutation. */
export type DeleteConsultationParticipantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `ConsultationParticipant` mutation. */
export type DeleteConsultationParticipantPayload = {
  __typename?: 'DeleteConsultationParticipantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Consultation` that is related to this `ConsultationParticipant`. */
  consultation: Maybe<Consultation>;
  /** The `ConsultationParticipant` that was deleted by this mutation. */
  consultationParticipant: Maybe<ConsultationParticipant>;
  /** An edge for our `ConsultationParticipant`. May be used by Relay 1. */
  consultationParticipantEdge: Maybe<ConsultationParticipantsEdge>;
  deletedConsultationParticipantNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ConsultationParticipant`. */
  user: Maybe<User>;
};


/** The output of our delete `ConsultationParticipant` mutation. */
export type DeleteConsultationParticipantPayloadConsultationParticipantEdgeArgs = {
  orderBy?: Array<ConsultationParticipantsOrderBy>;
};

/** The output of our delete `Consultation` mutation. */
export type DeleteConsultationPayload = {
  __typename?: 'DeleteConsultationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Consultation` that was deleted by this mutation. */
  consultation: Maybe<Consultation>;
  /** An edge for our `Consultation`. May be used by Relay 1. */
  consultationEdge: Maybe<ConsultationsEdge>;
  deletedConsultationNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `Consultation`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Consultation` mutation. */
export type DeleteConsultationPayloadConsultationEdgeArgs = {
  orderBy?: Array<ConsultationsOrderBy>;
};

/** All input for the `deleteMessageBodyRevisionApprovalByNodeId` mutation. */
export type DeleteMessageBodyRevisionApprovalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageBodyRevisionApproval` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMessageBodyRevisionApproval` mutation. */
export type DeleteMessageBodyRevisionApprovalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `MessageBodyRevisionApproval` mutation. */
export type DeleteMessageBodyRevisionApprovalPayload = {
  __typename?: 'DeleteMessageBodyRevisionApprovalPayload';
  /** Reads a single `User` that is related to this `MessageBodyRevisionApproval`. */
  approver: Maybe<User>;
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionApproval`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedMessageBodyRevisionApprovalNodeId: Maybe<Scalars['ID']['output']>;
  /** The `MessageBodyRevisionApproval` that was deleted by this mutation. */
  messageBodyRevisionApproval: Maybe<MessageBodyRevisionApproval>;
  /** An edge for our `MessageBodyRevisionApproval`. May be used by Relay 1. */
  messageBodyRevisionApprovalEdge: Maybe<MessageBodyRevisionApprovalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `MessageBodyRevisionApproval` mutation. */
export type DeleteMessageBodyRevisionApprovalPayloadMessageBodyRevisionApprovalEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionApprovalsOrderBy>;
};

/** All input for the `deleteMessageBodyRevisionByNodeId` mutation. */
export type DeleteMessageBodyRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageBodyRevision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMessageBodyRevisionCommentByNodeId` mutation. */
export type DeleteMessageBodyRevisionCommentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageBodyRevisionComment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMessageBodyRevisionComment` mutation. */
export type DeleteMessageBodyRevisionCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `MessageBodyRevisionComment` mutation. */
export type DeleteMessageBodyRevisionCommentPayload = {
  __typename?: 'DeleteMessageBodyRevisionCommentPayload';
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionComment`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `MessageBodyRevisionComment`. */
  commenter: Maybe<User>;
  deletedMessageBodyRevisionCommentNodeId: Maybe<Scalars['ID']['output']>;
  /** The `MessageBodyRevisionComment` that was deleted by this mutation. */
  messageBodyRevisionComment: Maybe<MessageBodyRevisionComment>;
  /** An edge for our `MessageBodyRevisionComment`. May be used by Relay 1. */
  messageBodyRevisionCommentEdge: Maybe<MessageBodyRevisionCommentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `MessageBodyRevisionComment` mutation. */
export type DeleteMessageBodyRevisionCommentPayloadMessageBodyRevisionCommentEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionCommentsOrderBy>;
};

/** All input for the `deleteMessageBodyRevision` mutation. */
export type DeleteMessageBodyRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `MessageBodyRevision` mutation. */
export type DeleteMessageBodyRevisionPayload = {
  __typename?: 'DeleteMessageBodyRevisionPayload';
  /** Reads a single `User` that is related to this `MessageBodyRevision`. */
  author: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedMessageBodyRevisionNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Message` that is related to this `MessageBodyRevision`. */
  message: Maybe<Message>;
  /** The `MessageBodyRevision` that was deleted by this mutation. */
  messageBodyRevision: Maybe<MessageBodyRevision>;
  /** An edge for our `MessageBodyRevision`. May be used by Relay 1. */
  messageBodyRevisionEdge: Maybe<MessageBodyRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `MessageBodyRevision` mutation. */
export type DeleteMessageBodyRevisionPayloadMessageBodyRevisionEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionsOrderBy>;
};

/** All input for the `deleteMessageByNodeId` mutation. */
export type DeleteMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Message` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteMessage` mutation. */
export type DeleteMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Message` mutation. */
export type DeleteMessagePayload = {
  __typename?: 'DeleteMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Consultation` that is related to this `Message`. */
  consultation: Maybe<Consultation>;
  deletedMessageNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Message` that was deleted by this mutation. */
  message: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Message`. */
  sender: Maybe<User>;
};


/** The output of our delete `Message` mutation. */
export type DeleteMessagePayloadMessageEdgeArgs = {
  orderBy?: Array<MessagesOrderBy>;
};

/** All input for the `deleteOrganizationByNodeId` mutation. */
export type DeleteOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organization` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganizationBySlug` mutation. */
export type DeleteOrganizationBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  slug: Scalars['String']['input'];
};

/** All input for the `deleteOrganization` mutation. */
export type DeleteOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** All input for the `deleteOrganizationInvitationByNodeId` mutation. */
export type DeleteOrganizationInvitationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganizationInvitation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganizationInvitationByOrganizationIdAndEmail` mutation. */
export type DeleteOrganizationInvitationByOrganizationIdAndEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  organizationId: Scalars['UUID']['input'];
};

/** All input for the `deleteOrganizationInvitationByOrganizationIdAndUserId` mutation. */
export type DeleteOrganizationInvitationByOrganizationIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** All input for the `deleteOrganizationInvitation` mutation. */
export type DeleteOrganizationInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `OrganizationInvitation` mutation. */
export type DeleteOrganizationInvitationPayload = {
  __typename?: 'DeleteOrganizationInvitationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedOrganizationInvitationNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationInvitation`. */
  organization: Maybe<Organization>;
  /** The `OrganizationInvitation` that was deleted by this mutation. */
  organizationInvitation: Maybe<OrganizationInvitation>;
  /** An edge for our `OrganizationInvitation`. May be used by Relay 1. */
  organizationInvitationEdge: Maybe<OrganizationInvitationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationInvitation`. */
  user: Maybe<User>;
};


/** The output of our delete `OrganizationInvitation` mutation. */
export type DeleteOrganizationInvitationPayloadOrganizationInvitationEdgeArgs = {
  orderBy?: Array<OrganizationInvitationsOrderBy>;
};

/** All input for the `deleteOrganizationMembershipByNodeId` mutation. */
export type DeleteOrganizationMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganizationMembership` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganizationMembershipByOrganizationIdAndUserId` mutation. */
export type DeleteOrganizationMembershipByOrganizationIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** All input for the `deleteOrganizationMembership` mutation. */
export type DeleteOrganizationMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `OrganizationMembership` mutation. */
export type DeleteOrganizationMembershipPayload = {
  __typename?: 'DeleteOrganizationMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedOrganizationMembershipNodeId: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationMembership`. */
  organization: Maybe<Organization>;
  /** The `OrganizationMembership` that was deleted by this mutation. */
  organizationMembership: Maybe<OrganizationMembership>;
  /** An edge for our `OrganizationMembership`. May be used by Relay 1. */
  organizationMembershipEdge: Maybe<OrganizationMembershipsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationMembership`. */
  user: Maybe<User>;
};


/** The output of our delete `OrganizationMembership` mutation. */
export type DeleteOrganizationMembershipPayloadOrganizationMembershipEdgeArgs = {
  orderBy?: Array<OrganizationMembershipsOrderBy>;
};

/** The output of our delete `Organization` mutation. */
export type DeleteOrganizationPayload = {
  __typename?: 'DeleteOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedOrganizationNodeId: Maybe<Scalars['ID']['output']>;
  /** The `Organization` that was deleted by this mutation. */
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our delete `Organization` mutation. */
export type DeleteOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `deleteUserAuthenticationByNodeId` mutation. */
export type DeleteUserAuthenticationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserAuthentication` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserAuthenticationByServiceAndIdentifier` mutation. */
export type DeleteUserAuthenticationByServiceAndIdentifierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['input'];
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['input'];
};

/** All input for the `deleteUserAuthentication` mutation. */
export type DeleteUserAuthenticationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `UserAuthentication` mutation. */
export type DeleteUserAuthenticationPayload = {
  __typename?: 'DeleteUserAuthenticationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserAuthenticationNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  /** The `UserAuthentication` that was deleted by this mutation. */
  userAuthentication: Maybe<UserAuthentication>;
  /** An edge for our `UserAuthentication`. May be used by Relay 1. */
  userAuthenticationEdge: Maybe<UserAuthenticationsEdge>;
};


/** The output of our delete `UserAuthentication` mutation. */
export type DeleteUserAuthenticationPayloadUserAuthenticationEdgeArgs = {
  orderBy?: Array<UserAuthenticationsOrderBy>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserByUsername` mutation. */
export type DeleteUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['input'];
};

/** All input for the `deleteUserEmailByNodeId` mutation. */
export type DeleteUserEmailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserEmail` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserEmailByUserIdAndEmail` mutation. */
export type DeleteUserEmailByUserIdAndEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

/** All input for the `deleteUserEmail` mutation. */
export type DeleteUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayload = {
  __typename?: 'DeleteUserEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserEmailNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  /** The `UserEmail` that was deleted by this mutation. */
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our delete `UserEmail` mutation. */
export type DeleteUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the user. */
  id: Scalars['UUID']['input'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  deletedUserNodeId: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `User` that was deleted by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: Array<UsersOrderBy>;
};

/** All input for the `forgotPassword` mutation. */
export type ForgotPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
};

/** The output of our `forgotPassword` mutation. */
export type ForgotPasswordPayload = {
  __typename?: 'ForgotPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `inviteToOrganization` mutation. */
export type InviteToOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `inviteToOrganization` mutation. */
export type InviteToOrganizationPayload = {
  __typename?: 'InviteToOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

export type LoginInput = {
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type LoginPayload = {
  __typename?: 'LoginPayload';
  user: User;
};

export type LogoutPayload = {
  __typename?: 'LogoutPayload';
  success: Maybe<Scalars['Boolean']['output']>;
};

/** All input for the `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  emailId: Scalars['UUID']['input'];
};

/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayload = {
  __typename?: 'MakeEmailPrimaryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our `makeEmailPrimary` mutation. */
export type MakeEmailPrimaryPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

export type Message = Node & {
  __typename?: 'Message';
  /** Reads a single `Consultation` that is related to this `Message`. */
  consultation: Maybe<Consultation>;
  consultationId: Scalars['UUID']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isForClients: Scalars['Boolean']['output'];
  isForStaff: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `MessageBodyRevision`. */
  messageBodyRevisions: MessageBodyRevisionsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `User` that is related to this `Message`. */
  sender: Maybe<User>;
  senderId: Maybe<Scalars['UUID']['output']>;
};


export type MessageMessageBodyRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionCondition>;
  filter?: InputMaybe<MessageBodyRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionsOrderBy>>;
};

export type MessageBodyRevision = Node & {
  __typename?: 'MessageBodyRevision';
  /** Reads a single `User` that is related to this `MessageBodyRevision`. */
  author: Maybe<User>;
  authorId: Maybe<Scalars['UUID']['output']>;
  content: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** Reads a single `Message` that is related to this `MessageBodyRevision`. */
  message: Maybe<Message>;
  /** Reads and enables pagination through a set of `MessageBodyRevisionApproval`. */
  messageBodyRevisionApprovalsByBodyRevisionId: MessageBodyRevisionApprovalsConnection;
  /** Reads and enables pagination through a set of `MessageBodyRevisionComment`. */
  messageBodyRevisionCommentsByBodyRevisionId: MessageBodyRevisionCommentsConnection;
  messageId: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
};


export type MessageBodyRevisionMessageBodyRevisionApprovalsByBodyRevisionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionApprovalCondition>;
  filter?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionApprovalsOrderBy>>;
};


export type MessageBodyRevisionMessageBodyRevisionCommentsByBodyRevisionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionCommentCondition>;
  filter?: InputMaybe<MessageBodyRevisionCommentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionCommentsOrderBy>>;
};

export type MessageBodyRevisionApproval = Node & {
  __typename?: 'MessageBodyRevisionApproval';
  /** Reads a single `User` that is related to this `MessageBodyRevisionApproval`. */
  approver: Maybe<User>;
  approverId: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionApproval`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  bodyRevisionId: Scalars['UUID']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `MessageBodyRevisionApproval` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type MessageBodyRevisionApprovalCondition = {
  /** Checks for equality with the object’s `approverId` field. */
  approverId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `bodyRevisionId` field. */
  bodyRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `MessageBodyRevisionApproval` object types. All fields are combined with a logical ‘and.’ */
export type MessageBodyRevisionApprovalFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageBodyRevisionApprovalFilter>>;
  /** Filter by the object’s `approver` relation. */
  approver?: InputMaybe<UserFilter>;
  /** A related `approver` exists. */
  approverExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `approverId` field. */
  approverId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `bodyRevision` relation. */
  bodyRevision?: InputMaybe<MessageBodyRevisionFilter>;
  /** Filter by the object’s `bodyRevisionId` field. */
  bodyRevisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageBodyRevisionApprovalFilter>>;
};

/** An input for mutations affecting `MessageBodyRevisionApproval` */
export type MessageBodyRevisionApprovalInput = {
  approverId?: InputMaybe<Scalars['UUID']['input']>;
  bodyRevisionId: Scalars['UUID']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `MessageBodyRevisionApproval`. Fields that are set will be updated. */
export type MessageBodyRevisionApprovalPatch = {
  approverId?: InputMaybe<Scalars['UUID']['input']>;
  bodyRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `MessageBodyRevisionApproval` values. */
export type MessageBodyRevisionApprovalsConnection = {
  __typename?: 'MessageBodyRevisionApprovalsConnection';
  /** A list of edges which contains the `MessageBodyRevisionApproval` and cursor to aid in pagination. */
  edges: Array<Maybe<MessageBodyRevisionApprovalsEdge>>;
  /** A list of `MessageBodyRevisionApproval` objects. */
  nodes: Array<Maybe<MessageBodyRevisionApproval>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MessageBodyRevisionApproval` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MessageBodyRevisionApproval` edge in the connection. */
export type MessageBodyRevisionApprovalsEdge = {
  __typename?: 'MessageBodyRevisionApprovalsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `MessageBodyRevisionApproval` at the end of the edge. */
  node: Maybe<MessageBodyRevisionApproval>;
};

/** Methods to use when ordering `MessageBodyRevisionApproval`. */
export type MessageBodyRevisionApprovalsOrderBy =
  | 'APPROVER_ID_ASC'
  | 'APPROVER_ID_DESC'
  | 'BODY_REVISION_ID_ASC'
  | 'BODY_REVISION_ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type MessageBodyRevisionComment = Node & {
  __typename?: 'MessageBodyRevisionComment';
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionComment`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  bodyRevisionId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `MessageBodyRevisionComment`. */
  commenter: Maybe<User>;
  commenterId: Maybe<Scalars['UUID']['output']>;
  content: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `MessageBodyRevisionComment` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type MessageBodyRevisionCommentCondition = {
  /** Checks for equality with the object’s `bodyRevisionId` field. */
  bodyRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `commenterId` field. */
  commenterId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `MessageBodyRevisionComment` object types. All fields are combined with a logical ‘and.’ */
export type MessageBodyRevisionCommentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageBodyRevisionCommentFilter>>;
  /** Filter by the object’s `bodyRevision` relation. */
  bodyRevision?: InputMaybe<MessageBodyRevisionFilter>;
  /** Filter by the object’s `bodyRevisionId` field. */
  bodyRevisionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `commenter` relation. */
  commenter?: InputMaybe<UserFilter>;
  /** A related `commenter` exists. */
  commenterExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `commenterId` field. */
  commenterId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MessageBodyRevisionCommentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageBodyRevisionCommentFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `MessageBodyRevisionComment` */
export type MessageBodyRevisionCommentInput = {
  bodyRevisionId: Scalars['UUID']['input'];
  commenterId?: InputMaybe<Scalars['UUID']['input']>;
  content: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `MessageBodyRevisionComment`. Fields that are set will be updated. */
export type MessageBodyRevisionCommentPatch = {
  bodyRevisionId?: InputMaybe<Scalars['UUID']['input']>;
  commenterId?: InputMaybe<Scalars['UUID']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `MessageBodyRevisionComment` values. */
export type MessageBodyRevisionCommentsConnection = {
  __typename?: 'MessageBodyRevisionCommentsConnection';
  /** A list of edges which contains the `MessageBodyRevisionComment` and cursor to aid in pagination. */
  edges: Array<Maybe<MessageBodyRevisionCommentsEdge>>;
  /** A list of `MessageBodyRevisionComment` objects. */
  nodes: Array<Maybe<MessageBodyRevisionComment>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MessageBodyRevisionComment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MessageBodyRevisionComment` edge in the connection. */
export type MessageBodyRevisionCommentsEdge = {
  __typename?: 'MessageBodyRevisionCommentsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `MessageBodyRevisionComment` at the end of the edge. */
  node: Maybe<MessageBodyRevisionComment>;
};

/** Methods to use when ordering `MessageBodyRevisionComment`. */
export type MessageBodyRevisionCommentsOrderBy =
  | 'BODY_REVISION_ID_ASC'
  | 'BODY_REVISION_ID_DESC'
  | 'COMMENTER_ID_ASC'
  | 'COMMENTER_ID_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/**
 * A condition to be used against `MessageBodyRevision` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type MessageBodyRevisionCondition = {
  /** Checks for equality with the object’s `authorId` field. */
  authorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `content` field. */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `messageId` field. */
  messageId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `MessageBodyRevision` object types. All fields are combined with a logical ‘and.’ */
export type MessageBodyRevisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageBodyRevisionFilter>>;
  /** Filter by the object’s `author` relation. */
  author?: InputMaybe<UserFilter>;
  /** A related `author` exists. */
  authorExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `authorId` field. */
  authorId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `content` field. */
  content?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `message` relation. */
  message?: InputMaybe<MessageFilter>;
  /** Filter by the object’s `messageBodyRevisionApprovalsByBodyRevisionId` relation. */
  messageBodyRevisionApprovalsByBodyRevisionId?: InputMaybe<MessageBodyRevisionToManyMessageBodyRevisionApprovalFilter>;
  /** Some related `messageBodyRevisionApprovalsByBodyRevisionId` exist. */
  messageBodyRevisionApprovalsByBodyRevisionIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `messageBodyRevisionCommentsByBodyRevisionId` relation. */
  messageBodyRevisionCommentsByBodyRevisionId?: InputMaybe<MessageBodyRevisionToManyMessageBodyRevisionCommentFilter>;
  /** Some related `messageBodyRevisionCommentsByBodyRevisionId` exist. */
  messageBodyRevisionCommentsByBodyRevisionIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `messageId` field. */
  messageId?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MessageBodyRevisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageBodyRevisionFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `MessageBodyRevision` */
export type MessageBodyRevisionInput = {
  authorId?: InputMaybe<Scalars['UUID']['input']>;
  content: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  messageId: Scalars['UUID']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `MessageBodyRevision`. Fields that are set will be updated. */
export type MessageBodyRevisionPatch = {
  authorId?: InputMaybe<Scalars['UUID']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  messageId?: InputMaybe<Scalars['UUID']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `MessageBodyRevisionApproval` object types. All fields are combined with a logical ‘and.’ */
export type MessageBodyRevisionToManyMessageBodyRevisionApprovalFilter = {
  /** Every related `MessageBodyRevisionApproval` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  /** No related `MessageBodyRevisionApproval` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  /** Some related `MessageBodyRevisionApproval` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageBodyRevisionApprovalFilter>;
};

/** A filter to be used against many `MessageBodyRevisionComment` object types. All fields are combined with a logical ‘and.’ */
export type MessageBodyRevisionToManyMessageBodyRevisionCommentFilter = {
  /** Every related `MessageBodyRevisionComment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageBodyRevisionCommentFilter>;
  /** No related `MessageBodyRevisionComment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageBodyRevisionCommentFilter>;
  /** Some related `MessageBodyRevisionComment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageBodyRevisionCommentFilter>;
};

/** A connection to a list of `MessageBodyRevision` values. */
export type MessageBodyRevisionsConnection = {
  __typename?: 'MessageBodyRevisionsConnection';
  /** A list of edges which contains the `MessageBodyRevision` and cursor to aid in pagination. */
  edges: Array<Maybe<MessageBodyRevisionsEdge>>;
  /** A list of `MessageBodyRevision` objects. */
  nodes: Array<Maybe<MessageBodyRevision>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MessageBodyRevision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MessageBodyRevision` edge in the connection. */
export type MessageBodyRevisionsEdge = {
  __typename?: 'MessageBodyRevisionsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `MessageBodyRevision` at the end of the edge. */
  node: Maybe<MessageBodyRevision>;
};

/** Methods to use when ordering `MessageBodyRevision`. */
export type MessageBodyRevisionsOrderBy =
  | 'AUTHOR_ID_ASC'
  | 'AUTHOR_ID_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MESSAGE_ID_ASC'
  | 'MESSAGE_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC';

/** A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type MessageCondition = {
  /** Checks for equality with the object’s `consultationId` field. */
  consultationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isForClients` field. */
  isForClients?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isForStaff` field. */
  isForStaff?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `senderId` field. */
  senderId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Message` object types. All fields are combined with a logical ‘and.’ */
export type MessageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MessageFilter>>;
  /** Filter by the object’s `consultation` relation. */
  consultation?: InputMaybe<ConsultationFilter>;
  /** Filter by the object’s `consultationId` field. */
  consultationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isForClients` field. */
  isForClients?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isForStaff` field. */
  isForStaff?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `messageBodyRevisions` relation. */
  messageBodyRevisions?: InputMaybe<MessageToManyMessageBodyRevisionFilter>;
  /** Some related `messageBodyRevisions` exist. */
  messageBodyRevisionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<MessageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MessageFilter>>;
  /** Filter by the object’s `sender` relation. */
  sender?: InputMaybe<UserFilter>;
  /** A related `sender` exists. */
  senderExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `senderId` field. */
  senderId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Message` */
export type MessageInput = {
  consultationId: Scalars['UUID']['input'];
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isForClients?: InputMaybe<Scalars['Boolean']['input']>;
  isForStaff?: InputMaybe<Scalars['Boolean']['input']>;
  senderId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `Message`. Fields that are set will be updated. */
export type MessagePatch = {
  consultationId?: InputMaybe<Scalars['UUID']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isForClients?: InputMaybe<Scalars['Boolean']['input']>;
  isForStaff?: InputMaybe<Scalars['Boolean']['input']>;
  senderId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against many `MessageBodyRevision` object types. All fields are combined with a logical ‘and.’ */
export type MessageToManyMessageBodyRevisionFilter = {
  /** Every related `MessageBodyRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageBodyRevisionFilter>;
  /** No related `MessageBodyRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageBodyRevisionFilter>;
  /** Some related `MessageBodyRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageBodyRevisionFilter>;
};

/** A connection to a list of `Message` values. */
export type MessagesConnection = {
  __typename?: 'MessagesConnection';
  /** A list of edges which contains the `Message` and cursor to aid in pagination. */
  edges: Array<Maybe<MessagesEdge>>;
  /** A list of `Message` objects. */
  nodes: Array<Maybe<Message>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Message` edge in the connection. */
export type MessagesEdge = {
  __typename?: 'MessagesEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Message` at the end of the edge. */
  node: Maybe<Message>;
};

/** Methods to use when ordering `Message`. */
export type MessagesOrderBy =
  | 'CONSULTATION_ID_ASC'
  | 'CONSULTATION_ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_FOR_CLIENTS_ASC'
  | 'IS_FOR_CLIENTS_DESC'
  | 'IS_FOR_STAFF_ASC'
  | 'IS_FOR_STAFF_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SENDER_ID_ASC'
  | 'SENDER_ID_DESC';

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  acceptInvitationToOrganization: Maybe<AcceptInvitationToOrganizationPayload>;
  /** Enter your old password and a new password to change your password. */
  changePassword: Maybe<ChangePasswordPayload>;
  /** If you're certain you want to delete your account, use `requestAccountDeletion` to request an account deletion token, and then supply the token through this mutation to complete account deletion. */
  confirmAccountDeletion: Maybe<ConfirmAccountDeletionPayload>;
  /** Creates a single `Consultation`. */
  createConsultation: Maybe<CreateConsultationPayload>;
  /** Creates a single `ConsultationParticipant`. */
  createConsultationParticipant: Maybe<CreateConsultationParticipantPayload>;
  /** Creates a single `Message`. */
  createMessage: Maybe<CreateMessagePayload>;
  /** Creates a single `MessageBodyRevision`. */
  createMessageBodyRevision: Maybe<CreateMessageBodyRevisionPayload>;
  /** Creates a single `MessageBodyRevisionApproval`. */
  createMessageBodyRevisionApproval: Maybe<CreateMessageBodyRevisionApprovalPayload>;
  /** Creates a single `MessageBodyRevisionComment`. */
  createMessageBodyRevisionComment: Maybe<CreateMessageBodyRevisionCommentPayload>;
  /** Creates a single `Organization`. */
  createOrganization: Maybe<CreateOrganizationPayload>;
  /** Creates a single `OrganizationInvitation`. */
  createOrganizationInvitation: Maybe<CreateOrganizationInvitationPayload>;
  /** Creates a single `OrganizationMembership`. */
  createOrganizationMembership: Maybe<CreateOrganizationMembershipPayload>;
  /** Creates a single `User`. */
  createUser: Maybe<CreateUserPayload>;
  /** Creates a single `UserAuthentication`. */
  createUserAuthentication: Maybe<CreateUserAuthenticationPayload>;
  /** Creates a single `UserEmail`. */
  createUserEmail: Maybe<CreateUserEmailPayload>;
  /** Deletes a single `Consultation` using a unique key. */
  deleteConsultation: Maybe<DeleteConsultationPayload>;
  /** Deletes a single `Consultation` using its globally unique id. */
  deleteConsultationByNodeId: Maybe<DeleteConsultationPayload>;
  /** Deletes a single `ConsultationParticipant` using a unique key. */
  deleteConsultationParticipant: Maybe<DeleteConsultationParticipantPayload>;
  /** Deletes a single `ConsultationParticipant` using a unique key. */
  deleteConsultationParticipantByConsultationIdAndUserId: Maybe<DeleteConsultationParticipantPayload>;
  /** Deletes a single `ConsultationParticipant` using its globally unique id. */
  deleteConsultationParticipantByNodeId: Maybe<DeleteConsultationParticipantPayload>;
  /** Deletes a single `Message` using a unique key. */
  deleteMessage: Maybe<DeleteMessagePayload>;
  /** Deletes a single `MessageBodyRevision` using a unique key. */
  deleteMessageBodyRevision: Maybe<DeleteMessageBodyRevisionPayload>;
  /** Deletes a single `MessageBodyRevisionApproval` using a unique key. */
  deleteMessageBodyRevisionApproval: Maybe<DeleteMessageBodyRevisionApprovalPayload>;
  /** Deletes a single `MessageBodyRevisionApproval` using its globally unique id. */
  deleteMessageBodyRevisionApprovalByNodeId: Maybe<DeleteMessageBodyRevisionApprovalPayload>;
  /** Deletes a single `MessageBodyRevision` using its globally unique id. */
  deleteMessageBodyRevisionByNodeId: Maybe<DeleteMessageBodyRevisionPayload>;
  /** Deletes a single `MessageBodyRevisionComment` using a unique key. */
  deleteMessageBodyRevisionComment: Maybe<DeleteMessageBodyRevisionCommentPayload>;
  /** Deletes a single `MessageBodyRevisionComment` using its globally unique id. */
  deleteMessageBodyRevisionCommentByNodeId: Maybe<DeleteMessageBodyRevisionCommentPayload>;
  /** Deletes a single `Message` using its globally unique id. */
  deleteMessageByNodeId: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Organization` using a unique key. */
  deleteOrganization: Maybe<DeleteOrganizationPayload>;
  /** Deletes a single `Organization` using its globally unique id. */
  deleteOrganizationByNodeId: Maybe<DeleteOrganizationPayload>;
  /** Deletes a single `Organization` using a unique key. */
  deleteOrganizationBySlug: Maybe<DeleteOrganizationPayload>;
  /** Deletes a single `OrganizationInvitation` using a unique key. */
  deleteOrganizationInvitation: Maybe<DeleteOrganizationInvitationPayload>;
  /** Deletes a single `OrganizationInvitation` using its globally unique id. */
  deleteOrganizationInvitationByNodeId: Maybe<DeleteOrganizationInvitationPayload>;
  /** Deletes a single `OrganizationInvitation` using a unique key. */
  deleteOrganizationInvitationByOrganizationIdAndEmail: Maybe<DeleteOrganizationInvitationPayload>;
  /** Deletes a single `OrganizationInvitation` using a unique key. */
  deleteOrganizationInvitationByOrganizationIdAndUserId: Maybe<DeleteOrganizationInvitationPayload>;
  /** Deletes a single `OrganizationMembership` using a unique key. */
  deleteOrganizationMembership: Maybe<DeleteOrganizationMembershipPayload>;
  /** Deletes a single `OrganizationMembership` using its globally unique id. */
  deleteOrganizationMembershipByNodeId: Maybe<DeleteOrganizationMembershipPayload>;
  /** Deletes a single `OrganizationMembership` using a unique key. */
  deleteOrganizationMembershipByOrganizationIdAndUserId: Maybe<DeleteOrganizationMembershipPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserAuthentication` using a unique key. */
  deleteUserAuthentication: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserAuthentication` using its globally unique id. */
  deleteUserAuthenticationByNodeId: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `UserAuthentication` using a unique key. */
  deleteUserAuthenticationByServiceAndIdentifier: Maybe<DeleteUserAuthenticationPayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByUsername: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserEmail` using a unique key. */
  deleteUserEmail: Maybe<DeleteUserEmailPayload>;
  /** Deletes a single `UserEmail` using its globally unique id. */
  deleteUserEmailByNodeId: Maybe<DeleteUserEmailPayload>;
  /** Deletes a single `UserEmail` using a unique key. */
  deleteUserEmailByUserIdAndEmail: Maybe<DeleteUserEmailPayload>;
  /** If you've forgotten your password, give us one of your email addresses and we'll send you a reset token. Note this only works if you have added an email address! */
  forgotPassword: Maybe<ForgotPasswordPayload>;
  inviteToOrganization: Maybe<InviteToOrganizationPayload>;
  /** Use this mutation to log in to your account; this login uses sessions so you do not need to take further action. */
  login: Maybe<LoginPayload>;
  /** Use this mutation to logout from your account. Don't forget to clear the client state! */
  logout: Maybe<LogoutPayload>;
  /** Your primary email is where we'll notify of account events; other emails may be used for discovery or login. Use this when you're changing your email address. */
  makeEmailPrimary: Maybe<MakeEmailPrimaryPayload>;
  /** Use this mutation to create an account on our system. This may only be used if you are logged out. */
  register: Maybe<RegisterPayload>;
  removeFromOrganization: Maybe<RemoveFromOrganizationPayload>;
  /** Begin the account deletion flow by requesting the confirmation email */
  requestAccountDeletion: Maybe<RequestAccountDeletionPayload>;
  /** If you didn't receive the verification code for this email, we can resend it. We silently cap the rate of resends on the backend, so calls to this function may not result in another email being sent if it has been called recently. */
  resendEmailVerificationCode: Maybe<ResendEmailVerificationCodePayload>;
  /** After triggering forgotPassword, you'll be sent a reset token. Combine this with your user ID and a new password to reset your password. */
  resetPassword: Maybe<ResetPasswordPayload>;
  transferOrganizationBillingContact: Maybe<TransferOrganizationBillingContactPayload>;
  transferOrganizationOwnership: Maybe<TransferOrganizationOwnershipPayload>;
  /** Updates a single `Consultation` using a unique key and a patch. */
  updateConsultation: Maybe<UpdateConsultationPayload>;
  /** Updates a single `Consultation` using its globally unique id and a patch. */
  updateConsultationByNodeId: Maybe<UpdateConsultationPayload>;
  /** Updates a single `ConsultationParticipant` using a unique key and a patch. */
  updateConsultationParticipant: Maybe<UpdateConsultationParticipantPayload>;
  /** Updates a single `ConsultationParticipant` using a unique key and a patch. */
  updateConsultationParticipantByConsultationIdAndUserId: Maybe<UpdateConsultationParticipantPayload>;
  /** Updates a single `ConsultationParticipant` using its globally unique id and a patch. */
  updateConsultationParticipantByNodeId: Maybe<UpdateConsultationParticipantPayload>;
  /** Updates a single `Message` using a unique key and a patch. */
  updateMessage: Maybe<UpdateMessagePayload>;
  /** Updates a single `MessageBodyRevision` using a unique key and a patch. */
  updateMessageBodyRevision: Maybe<UpdateMessageBodyRevisionPayload>;
  /** Updates a single `MessageBodyRevisionApproval` using a unique key and a patch. */
  updateMessageBodyRevisionApproval: Maybe<UpdateMessageBodyRevisionApprovalPayload>;
  /** Updates a single `MessageBodyRevisionApproval` using its globally unique id and a patch. */
  updateMessageBodyRevisionApprovalByNodeId: Maybe<UpdateMessageBodyRevisionApprovalPayload>;
  /** Updates a single `MessageBodyRevision` using its globally unique id and a patch. */
  updateMessageBodyRevisionByNodeId: Maybe<UpdateMessageBodyRevisionPayload>;
  /** Updates a single `MessageBodyRevisionComment` using a unique key and a patch. */
  updateMessageBodyRevisionComment: Maybe<UpdateMessageBodyRevisionCommentPayload>;
  /** Updates a single `MessageBodyRevisionComment` using its globally unique id and a patch. */
  updateMessageBodyRevisionCommentByNodeId: Maybe<UpdateMessageBodyRevisionCommentPayload>;
  /** Updates a single `Message` using its globally unique id and a patch. */
  updateMessageByNodeId: Maybe<UpdateMessagePayload>;
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganization: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Organization` using its globally unique id and a patch. */
  updateOrganizationByNodeId: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `Organization` using a unique key and a patch. */
  updateOrganizationBySlug: Maybe<UpdateOrganizationPayload>;
  /** Updates a single `OrganizationInvitation` using a unique key and a patch. */
  updateOrganizationInvitation: Maybe<UpdateOrganizationInvitationPayload>;
  /** Updates a single `OrganizationInvitation` using its globally unique id and a patch. */
  updateOrganizationInvitationByNodeId: Maybe<UpdateOrganizationInvitationPayload>;
  /** Updates a single `OrganizationInvitation` using a unique key and a patch. */
  updateOrganizationInvitationByOrganizationIdAndEmail: Maybe<UpdateOrganizationInvitationPayload>;
  /** Updates a single `OrganizationInvitation` using a unique key and a patch. */
  updateOrganizationInvitationByOrganizationIdAndUserId: Maybe<UpdateOrganizationInvitationPayload>;
  /** Updates a single `OrganizationMembership` using a unique key and a patch. */
  updateOrganizationMembership: Maybe<UpdateOrganizationMembershipPayload>;
  /** Updates a single `OrganizationMembership` using its globally unique id and a patch. */
  updateOrganizationMembershipByNodeId: Maybe<UpdateOrganizationMembershipPayload>;
  /** Updates a single `OrganizationMembership` using a unique key and a patch. */
  updateOrganizationMembershipByOrganizationIdAndUserId: Maybe<UpdateOrganizationMembershipPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser: Maybe<UpdateUserPayload>;
  /** Updates a single `UserAuthentication` using a unique key and a patch. */
  updateUserAuthentication: Maybe<UpdateUserAuthenticationPayload>;
  /** Updates a single `UserAuthentication` using its globally unique id and a patch. */
  updateUserAuthenticationByNodeId: Maybe<UpdateUserAuthenticationPayload>;
  /** Updates a single `UserAuthentication` using a unique key and a patch. */
  updateUserAuthenticationByServiceAndIdentifier: Maybe<UpdateUserAuthenticationPayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByUsername: Maybe<UpdateUserPayload>;
  /** Updates a single `UserEmail` using a unique key and a patch. */
  updateUserEmail: Maybe<UpdateUserEmailPayload>;
  /** Updates a single `UserEmail` using its globally unique id and a patch. */
  updateUserEmailByNodeId: Maybe<UpdateUserEmailPayload>;
  /** Updates a single `UserEmail` using a unique key and a patch. */
  updateUserEmailByUserIdAndEmail: Maybe<UpdateUserEmailPayload>;
  /** Once you have received a verification token for your email, you may call this mutation with that token to make your email verified. */
  verifyEmail: Maybe<VerifyEmailPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAcceptInvitationToOrganizationArgs = {
  input: AcceptInvitationToOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationConfirmAccountDeletionArgs = {
  input: ConfirmAccountDeletionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateConsultationArgs = {
  input: CreateConsultationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateConsultationParticipantArgs = {
  input: CreateConsultationParticipantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageArgs = {
  input: CreateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageBodyRevisionArgs = {
  input: CreateMessageBodyRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageBodyRevisionApprovalArgs = {
  input: CreateMessageBodyRevisionApprovalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMessageBodyRevisionCommentArgs = {
  input: CreateMessageBodyRevisionCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganizationArgs = {
  input: CreateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganizationInvitationArgs = {
  input: CreateOrganizationInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganizationMembershipArgs = {
  input: CreateOrganizationMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserAuthenticationArgs = {
  input: CreateUserAuthenticationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserEmailArgs = {
  input: CreateUserEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteConsultationArgs = {
  input: DeleteConsultationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteConsultationByNodeIdArgs = {
  input: DeleteConsultationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteConsultationParticipantArgs = {
  input: DeleteConsultationParticipantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteConsultationParticipantByConsultationIdAndUserIdArgs = {
  input: DeleteConsultationParticipantByConsultationIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteConsultationParticipantByNodeIdArgs = {
  input: DeleteConsultationParticipantByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageArgs = {
  input: DeleteMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageBodyRevisionArgs = {
  input: DeleteMessageBodyRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageBodyRevisionApprovalArgs = {
  input: DeleteMessageBodyRevisionApprovalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageBodyRevisionApprovalByNodeIdArgs = {
  input: DeleteMessageBodyRevisionApprovalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageBodyRevisionByNodeIdArgs = {
  input: DeleteMessageBodyRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageBodyRevisionCommentArgs = {
  input: DeleteMessageBodyRevisionCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageBodyRevisionCommentByNodeIdArgs = {
  input: DeleteMessageBodyRevisionCommentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMessageByNodeIdArgs = {
  input: DeleteMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationArgs = {
  input: DeleteOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationByNodeIdArgs = {
  input: DeleteOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationBySlugArgs = {
  input: DeleteOrganizationBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationInvitationArgs = {
  input: DeleteOrganizationInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationInvitationByNodeIdArgs = {
  input: DeleteOrganizationInvitationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationInvitationByOrganizationIdAndEmailArgs = {
  input: DeleteOrganizationInvitationByOrganizationIdAndEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationInvitationByOrganizationIdAndUserIdArgs = {
  input: DeleteOrganizationInvitationByOrganizationIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationMembershipArgs = {
  input: DeleteOrganizationMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationMembershipByNodeIdArgs = {
  input: DeleteOrganizationMembershipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganizationMembershipByOrganizationIdAndUserIdArgs = {
  input: DeleteOrganizationMembershipByOrganizationIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationArgs = {
  input: DeleteUserAuthenticationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationByNodeIdArgs = {
  input: DeleteUserAuthenticationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserAuthenticationByServiceAndIdentifierArgs = {
  input: DeleteUserAuthenticationByServiceAndIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByUsernameArgs = {
  input: DeleteUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailArgs = {
  input: DeleteUserEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailByNodeIdArgs = {
  input: DeleteUserEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserEmailByUserIdAndEmailArgs = {
  input: DeleteUserEmailByUserIdAndEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationForgotPasswordArgs = {
  input: ForgotPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationInviteToOrganizationArgs = {
  input: InviteToOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMakeEmailPrimaryArgs = {
  input: MakeEmailPrimaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRegisterArgs = {
  input: RegisterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRemoveFromOrganizationArgs = {
  input: RemoveFromOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRequestAccountDeletionArgs = {
  input: RequestAccountDeletionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResendEmailVerificationCodeArgs = {
  input: ResendEmailVerificationCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTransferOrganizationBillingContactArgs = {
  input: TransferOrganizationBillingContactInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTransferOrganizationOwnershipArgs = {
  input: TransferOrganizationOwnershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateConsultationArgs = {
  input: UpdateConsultationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateConsultationByNodeIdArgs = {
  input: UpdateConsultationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateConsultationParticipantArgs = {
  input: UpdateConsultationParticipantInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateConsultationParticipantByConsultationIdAndUserIdArgs = {
  input: UpdateConsultationParticipantByConsultationIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateConsultationParticipantByNodeIdArgs = {
  input: UpdateConsultationParticipantByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageArgs = {
  input: UpdateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageBodyRevisionArgs = {
  input: UpdateMessageBodyRevisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageBodyRevisionApprovalArgs = {
  input: UpdateMessageBodyRevisionApprovalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageBodyRevisionApprovalByNodeIdArgs = {
  input: UpdateMessageBodyRevisionApprovalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageBodyRevisionByNodeIdArgs = {
  input: UpdateMessageBodyRevisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageBodyRevisionCommentArgs = {
  input: UpdateMessageBodyRevisionCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageBodyRevisionCommentByNodeIdArgs = {
  input: UpdateMessageBodyRevisionCommentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMessageByNodeIdArgs = {
  input: UpdateMessageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationByNodeIdArgs = {
  input: UpdateOrganizationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationBySlugArgs = {
  input: UpdateOrganizationBySlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationInvitationArgs = {
  input: UpdateOrganizationInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationInvitationByNodeIdArgs = {
  input: UpdateOrganizationInvitationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationInvitationByOrganizationIdAndEmailArgs = {
  input: UpdateOrganizationInvitationByOrganizationIdAndEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationInvitationByOrganizationIdAndUserIdArgs = {
  input: UpdateOrganizationInvitationByOrganizationIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationMembershipArgs = {
  input: UpdateOrganizationMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationMembershipByNodeIdArgs = {
  input: UpdateOrganizationMembershipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganizationMembershipByOrganizationIdAndUserIdArgs = {
  input: UpdateOrganizationMembershipByOrganizationIdAndUserIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserAuthenticationArgs = {
  input: UpdateUserAuthenticationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserAuthenticationByNodeIdArgs = {
  input: UpdateUserAuthenticationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserAuthenticationByServiceAndIdentifierArgs = {
  input: UpdateUserAuthenticationByServiceAndIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByUsernameArgs = {
  input: UpdateUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserEmailArgs = {
  input: UpdateUserEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserEmailByNodeIdArgs = {
  input: UpdateUserEmailByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserEmailByUserIdAndEmailArgs = {
  input: UpdateUserEmailByUserIdAndEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type Organization = Node & {
  __typename?: 'Organization';
  /** Reads and enables pagination through a set of `Consultation`. */
  consultations: ConsultationsConnection;
  createdAt: Scalars['Datetime']['output'];
  currentUserIsBillingContact: Maybe<Scalars['Boolean']['output']>;
  currentUserIsOwner: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationInvitation`. */
  organizationInvitations: OrganizationInvitationsConnection;
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: OrganizationMembershipsConnection;
  slug: Scalars['String']['output'];
};


export type OrganizationConsultationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ConsultationCondition>;
  filter?: InputMaybe<ConsultationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultationsOrderBy>>;
};


export type OrganizationOrganizationInvitationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationInvitationCondition>;
  filter?: InputMaybe<OrganizationInvitationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationInvitationsOrderBy>>;
};


export type OrganizationOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};

/**
 * A condition to be used against `Organization` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganizationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currentUserIsBillingContact` field. */
  currentUserIsBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `currentUserIsOwner` field. */
  currentUserIsOwner?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `slug` field. */
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Organization` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `consultations` relation. */
  consultations?: InputMaybe<OrganizationToManyConsultationFilter>;
  /** Some related `consultations` exist. */
  consultationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currentUserIsBillingContact` field. */
  currentUserIsBillingContact?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `currentUserIsOwner` field. */
  currentUserIsOwner?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationFilter>>;
  /** Filter by the object’s `organizationInvitations` relation. */
  organizationInvitations?: InputMaybe<OrganizationToManyOrganizationInvitationFilter>;
  /** Some related `organizationInvitations` exist. */
  organizationInvitationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organizationMemberships` relation. */
  organizationMemberships?: InputMaybe<OrganizationToManyOrganizationMembershipFilter>;
  /** Some related `organizationMemberships` exist. */
  organizationMembershipsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `slug` field. */
  slug?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Organization` */
export type OrganizationInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  name: Scalars['String']['input'];
  slug: Scalars['String']['input'];
};

export type OrganizationInvitation = Node & {
  __typename?: 'OrganizationInvitation';
  code: Maybe<Scalars['String']['output']>;
  email: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `OrganizationInvitation`. */
  organization: Maybe<Organization>;
  organizationId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `OrganizationInvitation`. */
  user: Maybe<User>;
  userId: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `OrganizationInvitation` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type OrganizationInvitationCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `OrganizationInvitation` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationInvitationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationInvitationFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationInvitationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationInvitationFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `OrganizationInvitation` */
export type OrganizationInvitationInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `OrganizationInvitation`. Fields that are set will be updated. */
export type OrganizationInvitationPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `OrganizationInvitation` values. */
export type OrganizationInvitationsConnection = {
  __typename?: 'OrganizationInvitationsConnection';
  /** A list of edges which contains the `OrganizationInvitation` and cursor to aid in pagination. */
  edges: Array<Maybe<OrganizationInvitationsEdge>>;
  /** A list of `OrganizationInvitation` objects. */
  nodes: Array<Maybe<OrganizationInvitation>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrganizationInvitation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OrganizationInvitation` edge in the connection. */
export type OrganizationInvitationsEdge = {
  __typename?: 'OrganizationInvitationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `OrganizationInvitation` at the end of the edge. */
  node: Maybe<OrganizationInvitation>;
};

/** Methods to use when ordering `OrganizationInvitation`. */
export type OrganizationInvitationsOrderBy =
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

export type OrganizationMembership = Node & {
  __typename?: 'OrganizationMembership';
  createdAt: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isBillingContact: Scalars['Boolean']['output'];
  isCounselor: Scalars['Boolean']['output'];
  isDispatcher: Scalars['Boolean']['output'];
  isOwner: Scalars['Boolean']['output'];
  isSupervisor: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organization` that is related to this `OrganizationMembership`. */
  organization: Maybe<Organization>;
  organizationId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `OrganizationMembership`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `OrganizationMembership` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type OrganizationMembershipCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isBillingContact` field. */
  isBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isCounselor` field. */
  isCounselor?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isDispatcher` field. */
  isDispatcher?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isOwner` field. */
  isOwner?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSupervisor` field. */
  isSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `organizationId` field. */
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationMembershipFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganizationMembershipFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isBillingContact` field. */
  isBillingContact?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isCounselor` field. */
  isCounselor?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isDispatcher` field. */
  isDispatcher?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOwner` field. */
  isOwner?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSupervisor` field. */
  isSupervisor?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganizationMembershipFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganizationMembershipFilter>>;
  /** Filter by the object’s `organization` relation. */
  organization?: InputMaybe<OrganizationFilter>;
  /** Filter by the object’s `organizationId` field. */
  organizationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `OrganizationMembership` */
export type OrganizationMembershipInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  isCounselor?: InputMaybe<Scalars['Boolean']['input']>;
  isDispatcher?: InputMaybe<Scalars['Boolean']['input']>;
  isOwner?: InputMaybe<Scalars['Boolean']['input']>;
  isSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** Represents an update to a `OrganizationMembership`. Fields that are set will be updated. */
export type OrganizationMembershipPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isBillingContact?: InputMaybe<Scalars['Boolean']['input']>;
  isCounselor?: InputMaybe<Scalars['Boolean']['input']>;
  isDispatcher?: InputMaybe<Scalars['Boolean']['input']>;
  isOwner?: InputMaybe<Scalars['Boolean']['input']>;
  isSupervisor?: InputMaybe<Scalars['Boolean']['input']>;
  organizationId?: InputMaybe<Scalars['UUID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `OrganizationMembership` values. */
export type OrganizationMembershipsConnection = {
  __typename?: 'OrganizationMembershipsConnection';
  /** A list of edges which contains the `OrganizationMembership` and cursor to aid in pagination. */
  edges: Array<Maybe<OrganizationMembershipsEdge>>;
  /** A list of `OrganizationMembership` objects. */
  nodes: Array<Maybe<OrganizationMembership>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrganizationMembership` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OrganizationMembership` edge in the connection. */
export type OrganizationMembershipsEdge = {
  __typename?: 'OrganizationMembershipsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `OrganizationMembership` at the end of the edge. */
  node: Maybe<OrganizationMembership>;
};

/** Methods to use when ordering `OrganizationMembership`. */
export type OrganizationMembershipsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_BILLING_CONTACT_ASC'
  | 'IS_BILLING_CONTACT_DESC'
  | 'IS_COUNSELOR_ASC'
  | 'IS_COUNSELOR_DESC'
  | 'IS_DISPATCHER_ASC'
  | 'IS_DISPATCHER_DESC'
  | 'IS_OWNER_ASC'
  | 'IS_OWNER_DESC'
  | 'IS_SUPERVISOR_ASC'
  | 'IS_SUPERVISOR_DESC'
  | 'NATURAL'
  | 'ORGANIZATION_ID_ASC'
  | 'ORGANIZATION_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** Represents an update to a `Organization`. Fields that are set will be updated. */
export type OrganizationPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `Consultation` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManyConsultationFilter = {
  /** Every related `Consultation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ConsultationFilter>;
  /** No related `Consultation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ConsultationFilter>;
  /** Some related `Consultation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ConsultationFilter>;
};

/** A filter to be used against many `OrganizationInvitation` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManyOrganizationInvitationFilter = {
  /** Every related `OrganizationInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationInvitationFilter>;
  /** No related `OrganizationInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationInvitationFilter>;
  /** Some related `OrganizationInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationInvitationFilter>;
};

/** A filter to be used against many `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type OrganizationToManyOrganizationMembershipFilter = {
  /** Every related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationMembershipFilter>;
  /** No related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationMembershipFilter>;
  /** Some related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationMembershipFilter>;
};

/** A connection to a list of `Organization` values. */
export type OrganizationsConnection = {
  __typename?: 'OrganizationsConnection';
  /** A list of edges which contains the `Organization` and cursor to aid in pagination. */
  edges: Array<Maybe<OrganizationsEdge>>;
  /** A list of `Organization` objects. */
  nodes: Array<Maybe<Organization>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organization` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organization` edge in the connection. */
export type OrganizationsEdge = {
  __typename?: 'OrganizationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `Organization` at the end of the edge. */
  node: Maybe<Organization>;
};

/** Methods to use when ordering `Organization`. */
export type OrganizationsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SLUG_ASC'
  | 'SLUG_DESC';

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['Cursor']['output']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Get a single `Consultation`. */
  consultation: Maybe<Consultation>;
  /** Reads a single `Consultation` using its globally unique `ID`. */
  consultationByNodeId: Maybe<Consultation>;
  /** Get a single `ConsultationParticipant`. */
  consultationParticipant: Maybe<ConsultationParticipant>;
  /** Get a single `ConsultationParticipant`. */
  consultationParticipantByConsultationIdAndUserId: Maybe<ConsultationParticipant>;
  /** Reads a single `ConsultationParticipant` using its globally unique `ID`. */
  consultationParticipantByNodeId: Maybe<ConsultationParticipant>;
  /** Reads and enables pagination through a set of `ConsultationParticipant`. */
  consultationParticipants: Maybe<ConsultationParticipantsConnection>;
  /** Reads and enables pagination through a set of `Consultation`. */
  consultations: Maybe<ConsultationsConnection>;
  /** Handy method to get the current session ID. */
  currentSessionId: Maybe<Scalars['UUID']['output']>;
  /** The currently logged in user (or null if not logged in). */
  currentUser: Maybe<User>;
  /** Reads and enables pagination through a set of `Uuid`. */
  currentUserConsultationIds: Maybe<CurrentUserConsultationIdsConnection>;
  /** Handy method to get the current user ID for use in RLS policies, etc; in GraphQL, use `currentUser{id}` instead. */
  currentUserId: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `Uuid`. */
  currentUserInvitedOrganizationIds: Maybe<CurrentUserInvitedOrganizationIdsConnection>;
  /** Reads and enables pagination through a set of `Uuid`. */
  currentUserMemberOrganizationIds: Maybe<CurrentUserMemberOrganizationIdsConnection>;
  /** Get a single `Message`. */
  message: Maybe<Message>;
  /** Get a single `MessageBodyRevision`. */
  messageBodyRevision: Maybe<MessageBodyRevision>;
  /** Get a single `MessageBodyRevisionApproval`. */
  messageBodyRevisionApproval: Maybe<MessageBodyRevisionApproval>;
  /** Reads a single `MessageBodyRevisionApproval` using its globally unique `ID`. */
  messageBodyRevisionApprovalByNodeId: Maybe<MessageBodyRevisionApproval>;
  /** Reads and enables pagination through a set of `MessageBodyRevisionApproval`. */
  messageBodyRevisionApprovals: Maybe<MessageBodyRevisionApprovalsConnection>;
  /** Reads a single `MessageBodyRevision` using its globally unique `ID`. */
  messageBodyRevisionByNodeId: Maybe<MessageBodyRevision>;
  /** Get a single `MessageBodyRevisionComment`. */
  messageBodyRevisionComment: Maybe<MessageBodyRevisionComment>;
  /** Reads a single `MessageBodyRevisionComment` using its globally unique `ID`. */
  messageBodyRevisionCommentByNodeId: Maybe<MessageBodyRevisionComment>;
  /** Reads and enables pagination through a set of `MessageBodyRevisionComment`. */
  messageBodyRevisionComments: Maybe<MessageBodyRevisionCommentsConnection>;
  /** Reads and enables pagination through a set of `MessageBodyRevision`. */
  messageBodyRevisions: Maybe<MessageBodyRevisionsConnection>;
  /** Reads a single `Message` using its globally unique `ID`. */
  messageByNodeId: Maybe<Message>;
  /** Reads and enables pagination through a set of `Message`. */
  messages: Maybe<MessagesConnection>;
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  /** Get a single `Organization`. */
  organization: Maybe<Organization>;
  /** Reads a single `Organization` using its globally unique `ID`. */
  organizationByNodeId: Maybe<Organization>;
  /** Get a single `Organization`. */
  organizationBySlug: Maybe<Organization>;
  organizationForInvitation: Maybe<Organization>;
  /** Get a single `OrganizationInvitation`. */
  organizationInvitation: Maybe<OrganizationInvitation>;
  /** Reads a single `OrganizationInvitation` using its globally unique `ID`. */
  organizationInvitationByNodeId: Maybe<OrganizationInvitation>;
  /** Get a single `OrganizationInvitation`. */
  organizationInvitationByOrganizationIdAndEmail: Maybe<OrganizationInvitation>;
  /** Get a single `OrganizationInvitation`. */
  organizationInvitationByOrganizationIdAndUserId: Maybe<OrganizationInvitation>;
  /** Reads and enables pagination through a set of `OrganizationInvitation`. */
  organizationInvitations: Maybe<OrganizationInvitationsConnection>;
  /** Get a single `OrganizationMembership`. */
  organizationMembership: Maybe<OrganizationMembership>;
  /** Reads a single `OrganizationMembership` using its globally unique `ID`. */
  organizationMembershipByNodeId: Maybe<OrganizationMembership>;
  /** Get a single `OrganizationMembership`. */
  organizationMembershipByOrganizationIdAndUserId: Maybe<OrganizationMembership>;
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: Maybe<OrganizationMembershipsConnection>;
  /** Reads and enables pagination through a set of `Organization`. */
  organizations: Maybe<OrganizationsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** Get a single `User`. */
  user: Maybe<User>;
  /** Get a single `UserAuthentication`. */
  userAuthentication: Maybe<UserAuthentication>;
  /** Reads a single `UserAuthentication` using its globally unique `ID`. */
  userAuthenticationByNodeId: Maybe<UserAuthentication>;
  /** Get a single `UserAuthentication`. */
  userAuthenticationByServiceAndIdentifier: Maybe<UserAuthentication>;
  /** Reads and enables pagination through a set of `UserAuthentication`. */
  userAuthentications: Maybe<UserAuthenticationsConnection>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId: Maybe<User>;
  /** Get a single `User`. */
  userByUsername: Maybe<User>;
  /** Get a single `UserEmail`. */
  userEmail: Maybe<UserEmail>;
  /** Reads a single `UserEmail` using its globally unique `ID`. */
  userEmailByNodeId: Maybe<UserEmail>;
  /** Get a single `UserEmail`. */
  userEmailByUserIdAndEmail: Maybe<UserEmail>;
  /** Reads and enables pagination through a set of `UserEmail`. */
  userEmails: Maybe<UserEmailsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users: Maybe<UsersConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryConsultationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryConsultationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryConsultationParticipantArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryConsultationParticipantByConsultationIdAndUserIdArgs = {
  consultationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryConsultationParticipantByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryConsultationParticipantsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ConsultationParticipantCondition>;
  filter?: InputMaybe<ConsultationParticipantFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultationParticipantsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryConsultationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ConsultationCondition>;
  filter?: InputMaybe<ConsultationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserConsultationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserInvitedOrganizationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserMemberOrganizationIdsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<UuidFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionApprovalArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionApprovalByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionApprovalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionApprovalCondition>;
  filter?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionApprovalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionCommentArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionCommentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionCommentCondition>;
  filter?: InputMaybe<MessageBodyRevisionCommentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionCommentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageBodyRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionCondition>;
  filter?: InputMaybe<MessageBodyRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMessageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageCondition>;
  filter?: InputMaybe<MessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationBySlugArgs = {
  slug: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationForInvitationArgs = {
  code?: InputMaybe<Scalars['String']['input']>;
  invitationId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationInvitationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationInvitationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationInvitationByOrganizationIdAndEmailArgs = {
  email: Scalars['String']['input'];
  organizationId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationInvitationByOrganizationIdAndUserIdArgs = {
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationInvitationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationInvitationCondition>;
  filter?: InputMaybe<OrganizationInvitationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationInvitationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipByOrganizationIdAndUserIdArgs = {
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganizationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationCondition>;
  filter?: InputMaybe<OrganizationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationByServiceAndIdentifierArgs = {
  identifier: Scalars['String']['input'];
  service: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserAuthenticationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserAuthenticationCondition>;
  filter?: InputMaybe<UserAuthenticationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserAuthenticationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByUsernameArgs = {
  username: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailByUserIdAndEmailArgs = {
  email: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserEmailCondition>;
  filter?: InputMaybe<UserEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

export type RegisterInput = {
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type RegisterPayload = {
  __typename?: 'RegisterPayload';
  user: User;
};

/** All input for the `removeFromOrganization` mutation. */
export type RemoveFromOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `removeFromOrganization` mutation. */
export type RemoveFromOrganizationPayload = {
  __typename?: 'RemoveFromOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `requestAccountDeletion` mutation. */
export type RequestAccountDeletionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `requestAccountDeletion` mutation. */
export type RequestAccountDeletionPayload = {
  __typename?: 'RequestAccountDeletionPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  emailId: Scalars['UUID']['input'];
};

/** The output of our `resendEmailVerificationCode` mutation. */
export type ResendEmailVerificationCodePayload = {
  __typename?: 'ResendEmailVerificationCodePayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  newPassword: Scalars['String']['input'];
  resetToken: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  success: Maybe<Scalars['Boolean']['output']>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactPayload = {
  __typename?: 'TransferOrganizationBillingContactPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `transferOrganizationBillingContact` mutation. */
export type TransferOrganizationBillingContactPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};

/** The output of our `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipPayload = {
  __typename?: 'TransferOrganizationOwnershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our `transferOrganizationOwnership` mutation. */
export type TransferOrganizationOwnershipPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

/** All input for the `updateConsultationByNodeId` mutation. */
export type UpdateConsultationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Consultation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Consultation` being updated. */
  patch: ConsultationPatch;
};

/** All input for the `updateConsultation` mutation. */
export type UpdateConsultationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Consultation` being updated. */
  patch: ConsultationPatch;
};

/** All input for the `updateConsultationParticipantByConsultationIdAndUserId` mutation. */
export type UpdateConsultationParticipantByConsultationIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  consultationId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `ConsultationParticipant` being updated. */
  patch: ConsultationParticipantPatch;
  userId: Scalars['UUID']['input'];
};

/** All input for the `updateConsultationParticipantByNodeId` mutation. */
export type UpdateConsultationParticipantByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ConsultationParticipant` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ConsultationParticipant` being updated. */
  patch: ConsultationParticipantPatch;
};

/** All input for the `updateConsultationParticipant` mutation. */
export type UpdateConsultationParticipantInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `ConsultationParticipant` being updated. */
  patch: ConsultationParticipantPatch;
};

/** The output of our update `ConsultationParticipant` mutation. */
export type UpdateConsultationParticipantPayload = {
  __typename?: 'UpdateConsultationParticipantPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Consultation` that is related to this `ConsultationParticipant`. */
  consultation: Maybe<Consultation>;
  /** The `ConsultationParticipant` that was updated by this mutation. */
  consultationParticipant: Maybe<ConsultationParticipant>;
  /** An edge for our `ConsultationParticipant`. May be used by Relay 1. */
  consultationParticipantEdge: Maybe<ConsultationParticipantsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `ConsultationParticipant`. */
  user: Maybe<User>;
};


/** The output of our update `ConsultationParticipant` mutation. */
export type UpdateConsultationParticipantPayloadConsultationParticipantEdgeArgs = {
  orderBy?: Array<ConsultationParticipantsOrderBy>;
};

/** The output of our update `Consultation` mutation. */
export type UpdateConsultationPayload = {
  __typename?: 'UpdateConsultationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Consultation` that was updated by this mutation. */
  consultation: Maybe<Consultation>;
  /** An edge for our `Consultation`. May be used by Relay 1. */
  consultationEdge: Maybe<ConsultationsEdge>;
  /** Reads a single `Organization` that is related to this `Consultation`. */
  organization: Maybe<Organization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Consultation` mutation. */
export type UpdateConsultationPayloadConsultationEdgeArgs = {
  orderBy?: Array<ConsultationsOrderBy>;
};

/** All input for the `updateMessageBodyRevisionApprovalByNodeId` mutation. */
export type UpdateMessageBodyRevisionApprovalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageBodyRevisionApproval` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `MessageBodyRevisionApproval` being updated. */
  patch: MessageBodyRevisionApprovalPatch;
};

/** All input for the `updateMessageBodyRevisionApproval` mutation. */
export type UpdateMessageBodyRevisionApprovalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MessageBodyRevisionApproval` being updated. */
  patch: MessageBodyRevisionApprovalPatch;
};

/** The output of our update `MessageBodyRevisionApproval` mutation. */
export type UpdateMessageBodyRevisionApprovalPayload = {
  __typename?: 'UpdateMessageBodyRevisionApprovalPayload';
  /** Reads a single `User` that is related to this `MessageBodyRevisionApproval`. */
  approver: Maybe<User>;
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionApproval`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `MessageBodyRevisionApproval` that was updated by this mutation. */
  messageBodyRevisionApproval: Maybe<MessageBodyRevisionApproval>;
  /** An edge for our `MessageBodyRevisionApproval`. May be used by Relay 1. */
  messageBodyRevisionApprovalEdge: Maybe<MessageBodyRevisionApprovalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `MessageBodyRevisionApproval` mutation. */
export type UpdateMessageBodyRevisionApprovalPayloadMessageBodyRevisionApprovalEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionApprovalsOrderBy>;
};

/** All input for the `updateMessageBodyRevisionByNodeId` mutation. */
export type UpdateMessageBodyRevisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageBodyRevision` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `MessageBodyRevision` being updated. */
  patch: MessageBodyRevisionPatch;
};

/** All input for the `updateMessageBodyRevisionCommentByNodeId` mutation. */
export type UpdateMessageBodyRevisionCommentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `MessageBodyRevisionComment` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `MessageBodyRevisionComment` being updated. */
  patch: MessageBodyRevisionCommentPatch;
};

/** All input for the `updateMessageBodyRevisionComment` mutation. */
export type UpdateMessageBodyRevisionCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MessageBodyRevisionComment` being updated. */
  patch: MessageBodyRevisionCommentPatch;
};

/** The output of our update `MessageBodyRevisionComment` mutation. */
export type UpdateMessageBodyRevisionCommentPayload = {
  __typename?: 'UpdateMessageBodyRevisionCommentPayload';
  /** Reads a single `MessageBodyRevision` that is related to this `MessageBodyRevisionComment`. */
  bodyRevision: Maybe<MessageBodyRevision>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `User` that is related to this `MessageBodyRevisionComment`. */
  commenter: Maybe<User>;
  /** The `MessageBodyRevisionComment` that was updated by this mutation. */
  messageBodyRevisionComment: Maybe<MessageBodyRevisionComment>;
  /** An edge for our `MessageBodyRevisionComment`. May be used by Relay 1. */
  messageBodyRevisionCommentEdge: Maybe<MessageBodyRevisionCommentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `MessageBodyRevisionComment` mutation. */
export type UpdateMessageBodyRevisionCommentPayloadMessageBodyRevisionCommentEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionCommentsOrderBy>;
};

/** All input for the `updateMessageBodyRevision` mutation. */
export type UpdateMessageBodyRevisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MessageBodyRevision` being updated. */
  patch: MessageBodyRevisionPatch;
};

/** The output of our update `MessageBodyRevision` mutation. */
export type UpdateMessageBodyRevisionPayload = {
  __typename?: 'UpdateMessageBodyRevisionPayload';
  /** Reads a single `User` that is related to this `MessageBodyRevision`. */
  author: Maybe<User>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Message` that is related to this `MessageBodyRevision`. */
  message: Maybe<Message>;
  /** The `MessageBodyRevision` that was updated by this mutation. */
  messageBodyRevision: Maybe<MessageBodyRevision>;
  /** An edge for our `MessageBodyRevision`. May be used by Relay 1. */
  messageBodyRevisionEdge: Maybe<MessageBodyRevisionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `MessageBodyRevision` mutation. */
export type UpdateMessageBodyRevisionPayloadMessageBodyRevisionEdgeArgs = {
  orderBy?: Array<MessageBodyRevisionsOrderBy>;
};

/** All input for the `updateMessageByNodeId` mutation. */
export type UpdateMessageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Message` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Message` being updated. */
  patch: MessagePatch;
};

/** All input for the `updateMessage` mutation. */
export type UpdateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Message` being updated. */
  patch: MessagePatch;
};

/** The output of our update `Message` mutation. */
export type UpdateMessagePayload = {
  __typename?: 'UpdateMessagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Consultation` that is related to this `Message`. */
  consultation: Maybe<Consultation>;
  /** The `Message` that was updated by this mutation. */
  message: Maybe<Message>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge: Maybe<MessagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `Message`. */
  sender: Maybe<User>;
};


/** The output of our update `Message` mutation. */
export type UpdateMessagePayloadMessageEdgeArgs = {
  orderBy?: Array<MessagesOrderBy>;
};

/** All input for the `updateOrganizationByNodeId` mutation. */
export type UpdateOrganizationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organization` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** All input for the `updateOrganizationBySlug` mutation. */
export type UpdateOrganizationBySlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
  slug: Scalars['String']['input'];
};

/** All input for the `updateOrganization` mutation. */
export type UpdateOrganizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Organization` being updated. */
  patch: OrganizationPatch;
};

/** All input for the `updateOrganizationInvitationByNodeId` mutation. */
export type UpdateOrganizationInvitationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganizationInvitation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `OrganizationInvitation` being updated. */
  patch: OrganizationInvitationPatch;
};

/** All input for the `updateOrganizationInvitationByOrganizationIdAndEmail` mutation. */
export type UpdateOrganizationInvitationByOrganizationIdAndEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  organizationId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `OrganizationInvitation` being updated. */
  patch: OrganizationInvitationPatch;
};

/** All input for the `updateOrganizationInvitationByOrganizationIdAndUserId` mutation. */
export type UpdateOrganizationInvitationByOrganizationIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `OrganizationInvitation` being updated. */
  patch: OrganizationInvitationPatch;
  userId: Scalars['UUID']['input'];
};

/** All input for the `updateOrganizationInvitation` mutation. */
export type UpdateOrganizationInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `OrganizationInvitation` being updated. */
  patch: OrganizationInvitationPatch;
};

/** The output of our update `OrganizationInvitation` mutation. */
export type UpdateOrganizationInvitationPayload = {
  __typename?: 'UpdateOrganizationInvitationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationInvitation`. */
  organization: Maybe<Organization>;
  /** The `OrganizationInvitation` that was updated by this mutation. */
  organizationInvitation: Maybe<OrganizationInvitation>;
  /** An edge for our `OrganizationInvitation`. May be used by Relay 1. */
  organizationInvitationEdge: Maybe<OrganizationInvitationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationInvitation`. */
  user: Maybe<User>;
};


/** The output of our update `OrganizationInvitation` mutation. */
export type UpdateOrganizationInvitationPayloadOrganizationInvitationEdgeArgs = {
  orderBy?: Array<OrganizationInvitationsOrderBy>;
};

/** All input for the `updateOrganizationMembershipByNodeId` mutation. */
export type UpdateOrganizationMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganizationMembership` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `OrganizationMembership` being updated. */
  patch: OrganizationMembershipPatch;
};

/** All input for the `updateOrganizationMembershipByOrganizationIdAndUserId` mutation. */
export type UpdateOrganizationMembershipByOrganizationIdAndUserIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  organizationId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `OrganizationMembership` being updated. */
  patch: OrganizationMembershipPatch;
  userId: Scalars['UUID']['input'];
};

/** All input for the `updateOrganizationMembership` mutation. */
export type UpdateOrganizationMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `OrganizationMembership` being updated. */
  patch: OrganizationMembershipPatch;
};

/** The output of our update `OrganizationMembership` mutation. */
export type UpdateOrganizationMembershipPayload = {
  __typename?: 'UpdateOrganizationMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organization` that is related to this `OrganizationMembership`. */
  organization: Maybe<Organization>;
  /** The `OrganizationMembership` that was updated by this mutation. */
  organizationMembership: Maybe<OrganizationMembership>;
  /** An edge for our `OrganizationMembership`. May be used by Relay 1. */
  organizationMembershipEdge: Maybe<OrganizationMembershipsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `OrganizationMembership`. */
  user: Maybe<User>;
};


/** The output of our update `OrganizationMembership` mutation. */
export type UpdateOrganizationMembershipPayloadOrganizationMembershipEdgeArgs = {
  orderBy?: Array<OrganizationMembershipsOrderBy>;
};

/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayload = {
  __typename?: 'UpdateOrganizationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The `Organization` that was updated by this mutation. */
  organization: Maybe<Organization>;
  /** An edge for our `Organization`. May be used by Relay 1. */
  organizationEdge: Maybe<OrganizationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};


/** The output of our update `Organization` mutation. */
export type UpdateOrganizationPayloadOrganizationEdgeArgs = {
  orderBy?: Array<OrganizationsOrderBy>;
};

/** All input for the `updateUserAuthenticationByNodeId` mutation. */
export type UpdateUserAuthenticationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserAuthentication` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserAuthentication` being updated. */
  patch: UserAuthenticationPatch;
};

/** All input for the `updateUserAuthenticationByServiceAndIdentifier` mutation. */
export type UpdateUserAuthenticationByServiceAndIdentifierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `UserAuthentication` being updated. */
  patch: UserAuthenticationPatch;
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['input'];
};

/** All input for the `updateUserAuthentication` mutation. */
export type UpdateUserAuthenticationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `UserAuthentication` being updated. */
  patch: UserAuthenticationPatch;
};

/** The output of our update `UserAuthentication` mutation. */
export type UpdateUserAuthenticationPayload = {
  __typename?: 'UpdateUserAuthenticationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  /** The `UserAuthentication` that was updated by this mutation. */
  userAuthentication: Maybe<UserAuthentication>;
  /** An edge for our `UserAuthentication`. May be used by Relay 1. */
  userAuthenticationEdge: Maybe<UserAuthenticationsEdge>;
};


/** The output of our update `UserAuthentication` mutation. */
export type UpdateUserAuthenticationPayloadUserAuthenticationEdgeArgs = {
  orderBy?: Array<UserAuthenticationsOrderBy>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByUsername` mutation. */
export type UpdateUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['input'];
};

/** All input for the `updateUserEmailByNodeId` mutation. */
export type UpdateUserEmailByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserEmail` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserEmail` being updated. */
  patch: UserEmailPatch;
};

/** All input for the `updateUserEmailByUserIdAndEmail` mutation. */
export type UpdateUserEmailByUserIdAndEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `UserEmail` being updated. */
  patch: UserEmailPatch;
  userId: Scalars['UUID']['input'];
};

/** All input for the `updateUserEmail` mutation. */
export type UpdateUserEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `UserEmail` being updated. */
  patch: UserEmailPatch;
};

/** The output of our update `UserEmail` mutation. */
export type UpdateUserEmailPayload = {
  __typename?: 'UpdateUserEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  /** The `UserEmail` that was updated by this mutation. */
  userEmail: Maybe<UserEmail>;
  /** An edge for our `UserEmail`. May be used by Relay 1. */
  userEmailEdge: Maybe<UserEmailsEdge>;
};


/** The output of our update `UserEmail` mutation. */
export type UpdateUserEmailPayloadUserEmailEdgeArgs = {
  orderBy?: Array<UserEmailsOrderBy>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the user. */
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Array<UsersOrderBy>;
};

/** A user who can log in to the application. */
export type User = Node & {
  __typename?: 'User';
  /** Reads and enables pagination through a set of `MessageBodyRevision`. */
  authoredMessageBodyRevisions: MessageBodyRevisionsConnection;
  /** Optional avatar URL. */
  avatarUrl: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ConsultationParticipant`. */
  consultationParticipants: ConsultationParticipantsConnection;
  createdAt: Scalars['Datetime']['output'];
  hasPassword: Maybe<Scalars['Boolean']['output']>;
  /** Unique identifier for the user. */
  id: Scalars['UUID']['output'];
  /** If true, the user has elevated privileges. */
  isAdmin: Scalars['Boolean']['output'];
  isVerified: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `MessageBodyRevisionApproval`. */
  messageBodyRevisionApprovalsByApproverId: MessageBodyRevisionApprovalsConnection;
  /** Reads and enables pagination through a set of `MessageBodyRevisionComment`. */
  messageBodyRevisionCommentsByCommenterId: MessageBodyRevisionCommentsConnection;
  /** Reads and enables pagination through a set of `Message`. */
  messagesBySenderId: MessagesConnection;
  /** Public-facing name (or pseudonym) of the user. */
  name: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganizationInvitation`. */
  organizationInvitations: OrganizationInvitationsConnection;
  /** Reads and enables pagination through a set of `OrganizationMembership`. */
  organizationMemberships: OrganizationMembershipsConnection;
  updatedAt: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `UserAuthentication`. */
  userAuthentications: UserAuthenticationsConnection;
  /** Reads and enables pagination through a set of `UserEmail`. */
  userEmails: UserEmailsConnection;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['output'];
};


/** A user who can log in to the application. */
export type UserAuthoredMessageBodyRevisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionCondition>;
  filter?: InputMaybe<MessageBodyRevisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserConsultationParticipantsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ConsultationParticipantCondition>;
  filter?: InputMaybe<ConsultationParticipantFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultationParticipantsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserMessageBodyRevisionApprovalsByApproverIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionApprovalCondition>;
  filter?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionApprovalsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserMessageBodyRevisionCommentsByCommenterIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageBodyRevisionCommentCondition>;
  filter?: InputMaybe<MessageBodyRevisionCommentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageBodyRevisionCommentsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserMessagesBySenderIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MessageCondition>;
  filter?: InputMaybe<MessageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};


/** A user who can log in to the application. */
export type UserOrganizationInvitationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationInvitationCondition>;
  filter?: InputMaybe<OrganizationInvitationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationInvitationsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserOrganizationMembershipsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganizationMembershipCondition>;
  filter?: InputMaybe<OrganizationMembershipFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganizationMembershipsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserUserAuthenticationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserAuthenticationCondition>;
  filter?: InputMaybe<UserAuthenticationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserAuthenticationsOrderBy>>;
};


/** A user who can log in to the application. */
export type UserUserEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserEmailCondition>;
  filter?: InputMaybe<UserEmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailsOrderBy>>;
};

/** Contains information about the login providers this user has used, so that they may disconnect them should they wish. */
export type UserAuthentication = Node & {
  __typename?: 'UserAuthentication';
  createdAt: Scalars['Datetime']['output'];
  /** Additional profile details extracted from this login method */
  details: Scalars['JSON']['output'];
  id: Scalars['UUID']['output'];
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `UserAuthentication`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `UserAuthentication` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserAuthenticationCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `details` field. */
  details?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `service` field. */
  service?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `UserAuthentication` object types. All fields are combined with a logical ‘and.’ */
export type UserAuthenticationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserAuthenticationFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `identifier` field. */
  identifier?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserAuthenticationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserAuthenticationFilter>>;
  /** Filter by the object’s `service` field. */
  service?: InputMaybe<StringFilter>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `UserAuthentication` */
export type UserAuthenticationInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Additional profile details extracted from this login method */
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** A unique identifier for the user within the login service. */
  identifier: Scalars['String']['input'];
  /** The login service used, e.g. `twitter` or `github`. */
  service: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId: Scalars['UUID']['input'];
};

/** Represents an update to a `UserAuthentication`. Fields that are set will be updated. */
export type UserAuthenticationPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Additional profile details extracted from this login method */
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** A unique identifier for the user within the login service. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** The login service used, e.g. `twitter` or `github`. */
  service?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `UserAuthentication` values. */
export type UserAuthenticationsConnection = {
  __typename?: 'UserAuthenticationsConnection';
  /** A list of edges which contains the `UserAuthentication` and cursor to aid in pagination. */
  edges: Array<Maybe<UserAuthenticationsEdge>>;
  /** A list of `UserAuthentication` objects. */
  nodes: Array<Maybe<UserAuthentication>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserAuthentication` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserAuthentication` edge in the connection. */
export type UserAuthenticationsEdge = {
  __typename?: 'UserAuthenticationsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UserAuthentication` at the end of the edge. */
  node: Maybe<UserAuthentication>;
};

/** Methods to use when ordering `UserAuthentication`. */
export type UserAuthenticationsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'DETAILS_ASC'
  | 'DETAILS_DESC'
  | 'IDENTIFIER_ASC'
  | 'IDENTIFIER_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SERVICE_ASC'
  | 'SERVICE_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `avatarUrl` field. */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `hasPassword` field. */
  hasPassword?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Information about a user's email address. */
export type UserEmail = Node & {
  __typename?: 'UserEmail';
  createdAt: Scalars['Datetime']['output'];
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  isPrimary: Scalars['Boolean']['output'];
  /** True if the user has is_verified their email address (by clicking the link in the email we sent them, or logging in with a social login provider), false otherwise. */
  isVerified: Scalars['Boolean']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  /** Reads a single `User` that is related to this `UserEmail`. */
  user: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `UserEmail` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserEmailCondition = {
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isPrimary` field. */
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `UserEmail` object types. All fields are combined with a logical ‘and.’ */
export type UserEmailFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserEmailFilter>>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isPrimary` field. */
  isPrimary?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserEmailFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserEmailFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `UserEmail` */
export type UserEmailInput = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** The users email address, in `a@b.c` format. */
  email: Scalars['String']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
  /** True if the user has is_verified their email address (by clicking the link in the email we sent them, or logging in with a social login provider), false otherwise. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Represents an update to a `UserEmail`. Fields that are set will be updated. */
export type UserEmailPatch = {
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** The users email address, in `a@b.c` format. */
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
  /** True if the user has is_verified their email address (by clicking the link in the email we sent them, or logging in with a social login provider), false otherwise. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `UserEmail` values. */
export type UserEmailsConnection = {
  __typename?: 'UserEmailsConnection';
  /** A list of edges which contains the `UserEmail` and cursor to aid in pagination. */
  edges: Array<Maybe<UserEmailsEdge>>;
  /** A list of `UserEmail` objects. */
  nodes: Array<Maybe<UserEmail>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserEmail` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserEmail` edge in the connection. */
export type UserEmailsEdge = {
  __typename?: 'UserEmailsEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `UserEmail` at the end of the edge. */
  node: Maybe<UserEmail>;
};

/** Methods to use when ordering `UserEmail`. */
export type UserEmailsOrderBy =
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_PRIMARY_ASC'
  | 'IS_PRIMARY_DESC'
  | 'IS_VERIFIED_ASC'
  | 'IS_VERIFIED_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC';

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `authoredMessageBodyRevisions` relation. */
  authoredMessageBodyRevisions?: InputMaybe<UserToManyMessageBodyRevisionFilter>;
  /** Some related `authoredMessageBodyRevisions` exist. */
  authoredMessageBodyRevisionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `avatarUrl` field. */
  avatarUrl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `consultationParticipants` relation. */
  consultationParticipants?: InputMaybe<UserToManyConsultationParticipantFilter>;
  /** Some related `consultationParticipants` exist. */
  consultationParticipantsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `hasPassword` field. */
  hasPassword?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `messageBodyRevisionApprovalsByApproverId` relation. */
  messageBodyRevisionApprovalsByApproverId?: InputMaybe<UserToManyMessageBodyRevisionApprovalFilter>;
  /** Some related `messageBodyRevisionApprovalsByApproverId` exist. */
  messageBodyRevisionApprovalsByApproverIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `messageBodyRevisionCommentsByCommenterId` relation. */
  messageBodyRevisionCommentsByCommenterId?: InputMaybe<UserToManyMessageBodyRevisionCommentFilter>;
  /** Some related `messageBodyRevisionCommentsByCommenterId` exist. */
  messageBodyRevisionCommentsByCommenterIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `messagesBySenderId` relation. */
  messagesBySenderId?: InputMaybe<UserToManyMessageFilter>;
  /** Some related `messagesBySenderId` exist. */
  messagesBySenderIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `organizationInvitations` relation. */
  organizationInvitations?: InputMaybe<UserToManyOrganizationInvitationFilter>;
  /** Some related `organizationInvitations` exist. */
  organizationInvitationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organizationMemberships` relation. */
  organizationMemberships?: InputMaybe<UserToManyOrganizationMembershipFilter>;
  /** Some related `organizationMemberships` exist. */
  organizationMembershipsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userAuthentications` relation. */
  userAuthentications?: InputMaybe<UserToManyUserAuthenticationFilter>;
  /** Some related `userAuthentications` exist. */
  userAuthenticationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userEmails` relation. */
  userEmails?: InputMaybe<UserToManyUserEmailFilter>;
  /** Some related `userEmails` exist. */
  userEmailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  /** Optional avatar URL. */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Unique identifier for the user. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** If true, the user has elevated privileges. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Public-facing name (or pseudonym) of the user. */
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Public-facing username (or 'handle') of the user. */
  username: Scalars['String']['input'];
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  /** Optional avatar URL. */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Unique identifier for the user. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** If true, the user has elevated privileges. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Public-facing name (or pseudonym) of the user. */
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Public-facing username (or 'handle') of the user. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `ConsultationParticipant` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyConsultationParticipantFilter = {
  /** Every related `ConsultationParticipant` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ConsultationParticipantFilter>;
  /** No related `ConsultationParticipant` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ConsultationParticipantFilter>;
  /** Some related `ConsultationParticipant` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ConsultationParticipantFilter>;
};

/** A filter to be used against many `MessageBodyRevisionApproval` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMessageBodyRevisionApprovalFilter = {
  /** Every related `MessageBodyRevisionApproval` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  /** No related `MessageBodyRevisionApproval` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageBodyRevisionApprovalFilter>;
  /** Some related `MessageBodyRevisionApproval` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageBodyRevisionApprovalFilter>;
};

/** A filter to be used against many `MessageBodyRevisionComment` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMessageBodyRevisionCommentFilter = {
  /** Every related `MessageBodyRevisionComment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageBodyRevisionCommentFilter>;
  /** No related `MessageBodyRevisionComment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageBodyRevisionCommentFilter>;
  /** Some related `MessageBodyRevisionComment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageBodyRevisionCommentFilter>;
};

/** A filter to be used against many `MessageBodyRevision` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMessageBodyRevisionFilter = {
  /** Every related `MessageBodyRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageBodyRevisionFilter>;
  /** No related `MessageBodyRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageBodyRevisionFilter>;
  /** Some related `MessageBodyRevision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageBodyRevisionFilter>;
};

/** A filter to be used against many `Message` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyMessageFilter = {
  /** Every related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MessageFilter>;
  /** No related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MessageFilter>;
  /** Some related `Message` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MessageFilter>;
};

/** A filter to be used against many `OrganizationInvitation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyOrganizationInvitationFilter = {
  /** Every related `OrganizationInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationInvitationFilter>;
  /** No related `OrganizationInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationInvitationFilter>;
  /** Some related `OrganizationInvitation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationInvitationFilter>;
};

/** A filter to be used against many `OrganizationMembership` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyOrganizationMembershipFilter = {
  /** Every related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganizationMembershipFilter>;
  /** No related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganizationMembershipFilter>;
  /** Some related `OrganizationMembership` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganizationMembershipFilter>;
};

/** A filter to be used against many `UserAuthentication` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserAuthenticationFilter = {
  /** Every related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserAuthenticationFilter>;
  /** No related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserAuthenticationFilter>;
  /** Some related `UserAuthentication` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserAuthenticationFilter>;
};

/** A filter to be used against many `UserEmail` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserEmailFilter = {
  /** Every related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserEmailFilter>;
  /** No related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserEmailFilter>;
  /** Some related `UserEmail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserEmailFilter>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<Maybe<UsersEdge>>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'AVATAR_URL_ASC'
  | 'AVATAR_URL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'IS_ADMIN_ASC'
  | 'IS_ADMIN_DESC'
  | 'IS_VERIFIED_ASC'
  | 'IS_VERIFIED_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC';

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  token: Scalars['String']['input'];
  userEmailId: Scalars['UUID']['input'];
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  boolean: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type LoginMutationVariables = Exact<{
  username: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type LoginMutation = { __typename?: 'Mutation', login: { __typename?: 'LoginPayload', user: { __typename?: 'User', id: string, username: string } } | null };


export const LoginDocument = gql`
    mutation Login($username: String!, $password: String!) {
  login(input: {username: $username, password: $password}) {
    user {
      id
      username
    }
  }
}
    `;

export function useLoginMutation() {
  return Urql.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument);
};